// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace biotech {
namespace osla {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class TinsQuaList;
class TinsQuaConfig;
class Heartbeat;
class InitPhase;
class Command;
class Instrument;
class InstrumentList;
class InstrumentBinding;
class InstrumentDetail;
class Reservation;
class ReservationList;
class User;
class UserList;
class Account;
class AccountList;
class UserRight;
class UserRightList;
class TempCardBinding;
class TempCardBindingList;
class Booking;
class BookingList;
class Calendar;
class CalendarList;
class GlobalConfig;
class Session;
class SessionList;
class UserInTraining;
class UserInTrainingList;
class UserEvent;
class UserEventList;
class SystemEvent;
class SystemEventList;
class FtpFileUpload;
class FtpEvent;
class FtpEventList;
class DeviceCaptureEvent;
class DeviceCaptureEventList;
class SessionOpertaionReq;
class SessionOpertaionRep;
class Entrust;
class EntrustList;
class EntrustEvent;
class EntrustEventList;
class UpgradeParams;
class UpgradePlan;

enum InitPhase_Option {
  InitPhase_Option_CLIENT_INIT_REQ = 1,
  InitPhase_Option_SERVER_DEVICE_INIT_DONE = 2,
  InitPhase_Option_SERVER_INIT_DONE = 3
};
bool InitPhase_Option_IsValid(int value);
const InitPhase_Option InitPhase_Option_Option_MIN = InitPhase_Option_CLIENT_INIT_REQ;
const InitPhase_Option InitPhase_Option_Option_MAX = InitPhase_Option_SERVER_INIT_DONE;
const int InitPhase_Option_Option_ARRAYSIZE = InitPhase_Option_Option_MAX + 1;

enum Command_Option {
  Command_Option_CLIENT_RECV_OK = 11,
  Command_Option_CLIENT_RECV_ERR = 12,
  Command_Option_CLIENT_PARSE_ERR = 13,
  Command_Option_CLIENT_PARSE_OK = 14,
  Command_Option_SERVER_RECV_OK = 21,
  Command_Option_SERVER_RECV_ERR = 22,
  Command_Option_SERVER_PARSE_OK = 23,
  Command_Option_SERVER_PARSE_ERR = 24
};
bool Command_Option_IsValid(int value);
const Command_Option Command_Option_Option_MIN = Command_Option_CLIENT_RECV_OK;
const Command_Option Command_Option_Option_MAX = Command_Option_SERVER_PARSE_ERR;
const int Command_Option_Option_ARRAYSIZE = Command_Option_Option_MAX + 1;

enum InstrumentBinding_Option {
  InstrumentBinding_Option_REQUEST_BINDING = 0,
  InstrumentBinding_Option_CONFIRM_BINDING = 1,
  InstrumentBinding_Option_RELEASE_BINDING = 2
};
bool InstrumentBinding_Option_IsValid(int value);
const InstrumentBinding_Option InstrumentBinding_Option_Option_MIN = InstrumentBinding_Option_REQUEST_BINDING;
const InstrumentBinding_Option InstrumentBinding_Option_Option_MAX = InstrumentBinding_Option_RELEASE_BINDING;
const int InstrumentBinding_Option_Option_ARRAYSIZE = InstrumentBinding_Option_Option_MAX + 1;

enum MessageType {
  HEARTBEAT = 1,
  COMMAND = 2,
  INSTRUMENT = 3,
  INSTRUMENTLIST = 4,
  INSTRUMENTBINDING = 5,
  INSTRUMENTDETAIL = 6,
  RESERVATION = 7,
  RESERVATIONLIST = 8,
  USER = 9,
  USERLIST = 10,
  ACCOUNT = 11,
  ACCOUNTLIST = 12,
  USERRIGHT = 13,
  USERRIGHTLIST = 14,
  TEMPCARDBINDING = 15,
  TEMPCARDBINDINGLIST = 16,
  BOOKING = 17,
  BOOKINGLIST = 18,
  SESSION = 19,
  SESSIONLIST = 20,
  USERINTRAINING = 21,
  USERINTRAININGLIST = 22,
  USEREVENT = 23,
  USEREVENTLIST = 24,
  SYSTEMEVENT = 25,
  SYSTEMEVENTLIST = 26,
  CALENDAR = 27,
  CALENDARLIST = 28,
  GLOBALCONFIG = 29,
  FTPEVENT = 30,
  FTPEVENTLIST = 31,
  SESSION_OPERATION_REQ_CMD = 33,
  SESSION_OPERATION_REP_CMD = 34,
  INIT_PHASE = 35,
  DEVICE_CAPTURE_EVENT = 36,
  DEVICE_CAPTURE_EVENT_LIST = 37,
  ENTRUST = 38,
  ENTRUST_LIST = 39,
  ENTRUST_EVENT = 40,
  ENTRUST_EVENT_LIST = 41,
  UPGRADE_PARAMS = 42,
  UPGRADE_PLAN = 43,
  TINSQUACFG_DATA = 44
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = HEARTBEAT;
const MessageType MessageType_MAX = TINSQUACFG_DATA;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

enum FTP_FILE_UPLOAD_STATUS {
  FTP_FILE_UPLOAD_SUCCESS = 0,
  FTP_FILE_UPLOAD_FAIL = 1
};
bool FTP_FILE_UPLOAD_STATUS_IsValid(int value);
const FTP_FILE_UPLOAD_STATUS FTP_FILE_UPLOAD_STATUS_MIN = FTP_FILE_UPLOAD_SUCCESS;
const FTP_FILE_UPLOAD_STATUS FTP_FILE_UPLOAD_STATUS_MAX = FTP_FILE_UPLOAD_FAIL;
const int FTP_FILE_UPLOAD_STATUS_ARRAYSIZE = FTP_FILE_UPLOAD_STATUS_MAX + 1;

// ===================================================================

class TinsQuaList : public ::google::protobuf::MessageLite {
 public:
  TinsQuaList();
  virtual ~TinsQuaList();

  TinsQuaList(const TinsQuaList& from);

  inline TinsQuaList& operator=(const TinsQuaList& from) {
    CopyFrom(from);
    return *this;
  }

  static const TinsQuaList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TinsQuaList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TinsQuaList* other);

  // implements Message ----------------------------------------------

  TinsQuaList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TinsQuaList& from);
  void MergeFrom(const TinsQuaList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.TinsQuaConfig tinsQuas = 1;
  inline int tinsquas_size() const;
  inline void clear_tinsquas();
  static const int kTinsQuasFieldNumber = 1;
  inline const ::biotech::osla::TinsQuaConfig& tinsquas(int index) const;
  inline ::biotech::osla::TinsQuaConfig* mutable_tinsquas(int index);
  inline ::biotech::osla::TinsQuaConfig* add_tinsquas();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::TinsQuaConfig >&
      tinsquas() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::TinsQuaConfig >*
      mutable_tinsquas();

  // @@protoc_insertion_point(class_scope:biotech.osla.TinsQuaList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::TinsQuaConfig > tinsquas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TinsQuaList* default_instance_;
};
// -------------------------------------------------------------------

class TinsQuaConfig : public ::google::protobuf::MessageLite {
 public:
  TinsQuaConfig();
  virtual ~TinsQuaConfig();

  TinsQuaConfig(const TinsQuaConfig& from);

  inline TinsQuaConfig& operator=(const TinsQuaConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const TinsQuaConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TinsQuaConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TinsQuaConfig* other);

  // implements Message ----------------------------------------------

  TinsQuaConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TinsQuaConfig& from);
  void MergeFrom(const TinsQuaConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required bool type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline bool type() const;
  inline void set_type(bool value);

  // optional string orgNum = 3;
  inline bool has_orgnum() const;
  inline void clear_orgnum();
  static const int kOrgNumFieldNumber = 3;
  inline const ::std::string& orgnum() const;
  inline void set_orgnum(const ::std::string& value);
  inline void set_orgnum(const char* value);
  inline void set_orgnum(const char* value, size_t size);
  inline ::std::string* mutable_orgnum();
  inline ::std::string* release_orgnum();
  inline void set_allocated_orgnum(::std::string* orgnum);

  // required int32 instrumentId = 4;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentIdFieldNumber = 4;
  inline ::google::protobuf::int32 instrumentid() const;
  inline void set_instrumentid(::google::protobuf::int32 value);

  // required int32 quaId = 5;
  inline bool has_quaid() const;
  inline void clear_quaid();
  static const int kQuaIdFieldNumber = 5;
  inline ::google::protobuf::int32 quaid() const;
  inline void set_quaid(::google::protobuf::int32 value);

  // required bool workTime = 6;
  inline bool has_worktime() const;
  inline void clear_worktime();
  static const int kWorkTimeFieldNumber = 6;
  inline bool worktime() const;
  inline void set_worktime(bool value);

  // required int32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.TinsQuaConfig)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_orgnum();
  inline void clear_has_orgnum();
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_quaid();
  inline void clear_has_quaid();
  inline void set_has_worktime();
  inline void clear_has_worktime();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 instrumentid_;
  ::std::string* orgnum_;
  bool type_;
  bool worktime_;
  ::google::protobuf::int32 quaid_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TinsQuaConfig* default_instance_;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::MessageLite {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  static const Heartbeat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Heartbeat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Heartbeat* other);

  // implements Message ----------------------------------------------

  Heartbeat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 client_timestamp = 1;
  inline bool has_client_timestamp() const;
  inline void clear_client_timestamp();
  static const int kClientTimestampFieldNumber = 1;
  inline ::google::protobuf::int32 client_timestamp() const;
  inline void set_client_timestamp(::google::protobuf::int32 value);

  // required int32 server_timestamp = 2;
  inline bool has_server_timestamp() const;
  inline void clear_server_timestamp();
  static const int kServerTimestampFieldNumber = 2;
  inline ::google::protobuf::int32 server_timestamp() const;
  inline void set_server_timestamp(::google::protobuf::int32 value);

  // optional int32 instrument_id = 3;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 3;
  inline ::google::protobuf::int32 instrument_id() const;
  inline void set_instrument_id(::google::protobuf::int32 value);

  // optional int32 client_state = 4;
  inline bool has_client_state() const;
  inline void clear_client_state();
  static const int kClientStateFieldNumber = 4;
  inline ::google::protobuf::int32 client_state() const;
  inline void set_client_state(::google::protobuf::int32 value);

  // optional string org_code = 5;
  inline bool has_org_code() const;
  inline void clear_org_code();
  static const int kOrgCodeFieldNumber = 5;
  inline const ::std::string& org_code() const;
  inline void set_org_code(const ::std::string& value);
  inline void set_org_code(const char* value);
  inline void set_org_code(const char* value, size_t size);
  inline ::std::string* mutable_org_code();
  inline ::std::string* release_org_code();
  inline void set_allocated_org_code(::std::string* org_code);

  // @@protoc_insertion_point(class_scope:biotech.osla.Heartbeat)
 private:
  inline void set_has_client_timestamp();
  inline void clear_has_client_timestamp();
  inline void set_has_server_timestamp();
  inline void clear_has_server_timestamp();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_client_state();
  inline void clear_has_client_state();
  inline void set_has_org_code();
  inline void clear_has_org_code();

  ::google::protobuf::int32 client_timestamp_;
  ::google::protobuf::int32 server_timestamp_;
  ::google::protobuf::int32 instrument_id_;
  ::google::protobuf::int32 client_state_;
  ::std::string* org_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Heartbeat* default_instance_;
};
// -------------------------------------------------------------------

class InitPhase : public ::google::protobuf::MessageLite {
 public:
  InitPhase();
  virtual ~InitPhase();

  InitPhase(const InitPhase& from);

  inline InitPhase& operator=(const InitPhase& from) {
    CopyFrom(from);
    return *this;
  }

  static const InitPhase& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitPhase* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitPhase* other);

  // implements Message ----------------------------------------------

  InitPhase* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitPhase& from);
  void MergeFrom(const InitPhase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InitPhase_Option Option;
  static const Option CLIENT_INIT_REQ = InitPhase_Option_CLIENT_INIT_REQ;
  static const Option SERVER_DEVICE_INIT_DONE = InitPhase_Option_SERVER_DEVICE_INIT_DONE;
  static const Option SERVER_INIT_DONE = InitPhase_Option_SERVER_INIT_DONE;
  static inline bool Option_IsValid(int value) {
    return InitPhase_Option_IsValid(value);
  }
  static const Option Option_MIN =
    InitPhase_Option_Option_MIN;
  static const Option Option_MAX =
    InitPhase_Option_Option_MAX;
  static const int Option_ARRAYSIZE =
    InitPhase_Option_Option_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .biotech.osla.InitPhase.Option option = 1;
  inline bool has_option() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 1;
  inline ::biotech::osla::InitPhase_Option option() const;
  inline void set_option(::biotech::osla::InitPhase_Option value);

  // optional string bind_code = 2;
  inline bool has_bind_code() const;
  inline void clear_bind_code();
  static const int kBindCodeFieldNumber = 2;
  inline const ::std::string& bind_code() const;
  inline void set_bind_code(const ::std::string& value);
  inline void set_bind_code(const char* value);
  inline void set_bind_code(const char* value, size_t size);
  inline ::std::string* mutable_bind_code();
  inline ::std::string* release_bind_code();
  inline void set_allocated_bind_code(::std::string* bind_code);

  // @@protoc_insertion_point(class_scope:biotech.osla.InitPhase)
 private:
  inline void set_has_option();
  inline void clear_has_option();
  inline void set_has_bind_code();
  inline void clear_has_bind_code();

  ::std::string* bind_code_;
  int option_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static InitPhase* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::MessageLite {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  static const Command& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Command* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Command_Option Option;
  static const Option CLIENT_RECV_OK = Command_Option_CLIENT_RECV_OK;
  static const Option CLIENT_RECV_ERR = Command_Option_CLIENT_RECV_ERR;
  static const Option CLIENT_PARSE_ERR = Command_Option_CLIENT_PARSE_ERR;
  static const Option CLIENT_PARSE_OK = Command_Option_CLIENT_PARSE_OK;
  static const Option SERVER_RECV_OK = Command_Option_SERVER_RECV_OK;
  static const Option SERVER_RECV_ERR = Command_Option_SERVER_RECV_ERR;
  static const Option SERVER_PARSE_OK = Command_Option_SERVER_PARSE_OK;
  static const Option SERVER_PARSE_ERR = Command_Option_SERVER_PARSE_ERR;
  static inline bool Option_IsValid(int value) {
    return Command_Option_IsValid(value);
  }
  static const Option Option_MIN =
    Command_Option_Option_MIN;
  static const Option Option_MAX =
    Command_Option_Option_MAX;
  static const int Option_ARRAYSIZE =
    Command_Option_Option_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .biotech.osla.Command.Option option = 1;
  inline bool has_option() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 1;
  inline ::biotech::osla::Command_Option option() const;
  inline void set_option(::biotech::osla::Command_Option value);

  // @@protoc_insertion_point(class_scope:biotech.osla.Command)
 private:
  inline void set_has_option();
  inline void clear_has_option();

  int option_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Instrument : public ::google::protobuf::MessageLite {
 public:
  Instrument();
  virtual ~Instrument();

  Instrument(const Instrument& from);

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }

  static const Instrument& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Instrument* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Instrument* other);

  // implements Message ----------------------------------------------

  Instrument* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Instrument& from);
  void MergeFrom(const Instrument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string org_code = 3;
  inline bool has_org_code() const;
  inline void clear_org_code();
  static const int kOrgCodeFieldNumber = 3;
  inline const ::std::string& org_code() const;
  inline void set_org_code(const ::std::string& value);
  inline void set_org_code(const char* value);
  inline void set_org_code(const char* value, size_t size);
  inline ::std::string* mutable_org_code();
  inline ::std::string* release_org_code();
  inline void set_allocated_org_code(::std::string* org_code);

  // @@protoc_insertion_point(class_scope:biotech.osla.Instrument)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_org_code();
  inline void clear_has_org_code();

  ::std::string* name_;
  ::std::string* org_code_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Instrument* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentList : public ::google::protobuf::MessageLite {
 public:
  InstrumentList();
  virtual ~InstrumentList();

  InstrumentList(const InstrumentList& from);

  inline InstrumentList& operator=(const InstrumentList& from) {
    CopyFrom(from);
    return *this;
  }

  static const InstrumentList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstrumentList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstrumentList* other);

  // implements Message ----------------------------------------------

  InstrumentList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstrumentList& from);
  void MergeFrom(const InstrumentList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.Instrument instrument = 1;
  inline int instrument_size() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 1;
  inline const ::biotech::osla::Instrument& instrument(int index) const;
  inline ::biotech::osla::Instrument* mutable_instrument(int index);
  inline ::biotech::osla::Instrument* add_instrument();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Instrument >&
      instrument() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Instrument >*
      mutable_instrument();

  // @@protoc_insertion_point(class_scope:biotech.osla.InstrumentList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::Instrument > instrument_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static InstrumentList* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentBinding : public ::google::protobuf::MessageLite {
 public:
  InstrumentBinding();
  virtual ~InstrumentBinding();

  InstrumentBinding(const InstrumentBinding& from);

  inline InstrumentBinding& operator=(const InstrumentBinding& from) {
    CopyFrom(from);
    return *this;
  }

  static const InstrumentBinding& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstrumentBinding* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstrumentBinding* other);

  // implements Message ----------------------------------------------

  InstrumentBinding* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstrumentBinding& from);
  void MergeFrom(const InstrumentBinding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InstrumentBinding_Option Option;
  static const Option REQUEST_BINDING = InstrumentBinding_Option_REQUEST_BINDING;
  static const Option CONFIRM_BINDING = InstrumentBinding_Option_CONFIRM_BINDING;
  static const Option RELEASE_BINDING = InstrumentBinding_Option_RELEASE_BINDING;
  static inline bool Option_IsValid(int value) {
    return InstrumentBinding_Option_IsValid(value);
  }
  static const Option Option_MIN =
    InstrumentBinding_Option_Option_MIN;
  static const Option Option_MAX =
    InstrumentBinding_Option_Option_MAX;
  static const int Option_ARRAYSIZE =
    InstrumentBinding_Option_Option_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required int32 instrument_id = 1;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 1;
  inline ::google::protobuf::int32 instrument_id() const;
  inline void set_instrument_id(::google::protobuf::int32 value);

  // required string client_mac_addr = 2;
  inline bool has_client_mac_addr() const;
  inline void clear_client_mac_addr();
  static const int kClientMacAddrFieldNumber = 2;
  inline const ::std::string& client_mac_addr() const;
  inline void set_client_mac_addr(const ::std::string& value);
  inline void set_client_mac_addr(const char* value);
  inline void set_client_mac_addr(const char* value, size_t size);
  inline ::std::string* mutable_client_mac_addr();
  inline ::std::string* release_client_mac_addr();
  inline void set_allocated_client_mac_addr(::std::string* client_mac_addr);

  // required int32 client_model = 3;
  inline bool has_client_model() const;
  inline void clear_client_model();
  static const int kClientModelFieldNumber = 3;
  inline ::google::protobuf::int32 client_model() const;
  inline void set_client_model(::google::protobuf::int32 value);

  // required string client_version = 4;
  inline bool has_client_version() const;
  inline void clear_client_version();
  static const int kClientVersionFieldNumber = 4;
  inline const ::std::string& client_version() const;
  inline void set_client_version(const ::std::string& value);
  inline void set_client_version(const char* value);
  inline void set_client_version(const char* value, size_t size);
  inline ::std::string* mutable_client_version();
  inline ::std::string* release_client_version();
  inline void set_allocated_client_version(::std::string* client_version);

  // required .biotech.osla.InstrumentBinding.Option option = 5;
  inline bool has_option() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 5;
  inline ::biotech::osla::InstrumentBinding_Option option() const;
  inline void set_option(::biotech::osla::InstrumentBinding_Option value);

  // optional string bindCode = 6;
  inline bool has_bindcode() const;
  inline void clear_bindcode();
  static const int kBindCodeFieldNumber = 6;
  inline const ::std::string& bindcode() const;
  inline void set_bindcode(const ::std::string& value);
  inline void set_bindcode(const char* value);
  inline void set_bindcode(const char* value, size_t size);
  inline ::std::string* mutable_bindcode();
  inline ::std::string* release_bindcode();
  inline void set_allocated_bindcode(::std::string* bindcode);

  // @@protoc_insertion_point(class_scope:biotech.osla.InstrumentBinding)
 private:
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_client_mac_addr();
  inline void clear_has_client_mac_addr();
  inline void set_has_client_model();
  inline void clear_has_client_model();
  inline void set_has_client_version();
  inline void clear_has_client_version();
  inline void set_has_option();
  inline void clear_has_option();
  inline void set_has_bindcode();
  inline void clear_has_bindcode();

  ::std::string* client_mac_addr_;
  ::google::protobuf::int32 instrument_id_;
  ::google::protobuf::int32 client_model_;
  ::std::string* client_version_;
  ::std::string* bindcode_;
  int option_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static InstrumentBinding* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentDetail : public ::google::protobuf::MessageLite {
 public:
  InstrumentDetail();
  virtual ~InstrumentDetail();

  InstrumentDetail(const InstrumentDetail& from);

  inline InstrumentDetail& operator=(const InstrumentDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const InstrumentDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstrumentDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstrumentDetail* other);

  // implements Message ----------------------------------------------

  InstrumentDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstrumentDetail& from);
  void MergeFrom(const InstrumentDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // required int32 min_interval = 4;
  inline bool has_min_interval() const;
  inline void clear_min_interval();
  static const int kMinIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 min_interval() const;
  inline void set_min_interval(::google::protobuf::int32 value);

  // required int32 booking_holding_time = 5;
  inline bool has_booking_holding_time() const;
  inline void clear_booking_holding_time();
  static const int kBookingHoldingTimeFieldNumber = 5;
  inline ::google::protobuf::int32 booking_holding_time() const;
  inline void set_booking_holding_time(::google::protobuf::int32 value);

  // required int32 alert_time = 6;
  inline bool has_alert_time() const;
  inline void clear_alert_time();
  static const int kAlertTimeFieldNumber = 6;
  inline ::google::protobuf::int32 alert_time() const;
  inline void set_alert_time(::google::protobuf::int32 value);

  // optional int32 off_delay_time = 7;
  inline bool has_off_delay_time() const;
  inline void clear_off_delay_time();
  static const int kOffDelayTimeFieldNumber = 7;
  inline ::google::protobuf::int32 off_delay_time() const;
  inline void set_off_delay_time(::google::protobuf::int32 value);

  // optional int32 min_off_time = 8;
  inline bool has_min_off_time() const;
  inline void clear_min_off_time();
  static const int kMinOffTimeFieldNumber = 8;
  inline ::google::protobuf::int32 min_off_time() const;
  inline void set_min_off_time(::google::protobuf::int32 value);

  // optional int32 alert_current = 9;
  inline bool has_alert_current() const;
  inline void clear_alert_current();
  static const int kAlertCurrentFieldNumber = 9;
  inline ::google::protobuf::int32 alert_current() const;
  inline void set_alert_current(::google::protobuf::int32 value);

  // optional string client_software_update_version = 10;
  inline bool has_client_software_update_version() const;
  inline void clear_client_software_update_version();
  static const int kClientSoftwareUpdateVersionFieldNumber = 10;
  inline const ::std::string& client_software_update_version() const;
  inline void set_client_software_update_version(const ::std::string& value);
  inline void set_client_software_update_version(const char* value);
  inline void set_client_software_update_version(const char* value, size_t size);
  inline ::std::string* mutable_client_software_update_version();
  inline ::std::string* release_client_software_update_version();
  inline void set_allocated_client_software_update_version(::std::string* client_software_update_version);

  // optional int32 booking_break_time = 11;
  inline bool has_booking_break_time() const;
  inline void clear_booking_break_time();
  static const int kBookingBreakTimeFieldNumber = 11;
  inline ::google::protobuf::int32 booking_break_time() const;
  inline void set_booking_break_time(::google::protobuf::int32 value);

  // optional bool looseMode = 12;
  inline bool has_loosemode() const;
  inline void clear_loosemode();
  static const int kLooseModeFieldNumber = 12;
  inline bool loosemode() const;
  inline void set_loosemode(bool value);

  // optional string working_time = 13;
  inline bool has_working_time() const;
  inline void clear_working_time();
  static const int kWorkingTimeFieldNumber = 13;
  inline const ::std::string& working_time() const;
  inline void set_working_time(const ::std::string& value);
  inline void set_working_time(const char* value);
  inline void set_working_time(const char* value, size_t size);
  inline ::std::string* mutable_working_time();
  inline ::std::string* release_working_time();
  inline void set_allocated_working_time(::std::string* working_time);

  // optional int32 bookingModelID = 14;
  inline bool has_bookingmodelid() const;
  inline void clear_bookingmodelid();
  static const int kBookingModelIDFieldNumber = 14;
  inline ::google::protobuf::int32 bookingmodelid() const;
  inline void set_bookingmodelid(::google::protobuf::int32 value);

  // optional string terImgUrl = 15;
  inline bool has_terimgurl() const;
  inline void clear_terimgurl();
  static const int kTerImgUrlFieldNumber = 15;
  inline const ::std::string& terimgurl() const;
  inline void set_terimgurl(const ::std::string& value);
  inline void set_terimgurl(const char* value);
  inline void set_terimgurl(const char* value, size_t size);
  inline ::std::string* mutable_terimgurl();
  inline ::std::string* release_terimgurl();
  inline void set_allocated_terimgurl(::std::string* terimgurl);

  // @@protoc_insertion_point(class_scope:biotech.osla.InstrumentDetail)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_min_interval();
  inline void clear_has_min_interval();
  inline void set_has_booking_holding_time();
  inline void clear_has_booking_holding_time();
  inline void set_has_alert_time();
  inline void clear_has_alert_time();
  inline void set_has_off_delay_time();
  inline void clear_has_off_delay_time();
  inline void set_has_min_off_time();
  inline void clear_has_min_off_time();
  inline void set_has_alert_current();
  inline void clear_has_alert_current();
  inline void set_has_client_software_update_version();
  inline void clear_has_client_software_update_version();
  inline void set_has_booking_break_time();
  inline void clear_has_booking_break_time();
  inline void set_has_loosemode();
  inline void clear_has_loosemode();
  inline void set_has_working_time();
  inline void clear_has_working_time();
  inline void set_has_bookingmodelid();
  inline void clear_has_bookingmodelid();
  inline void set_has_terimgurl();
  inline void clear_has_terimgurl();

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 min_interval_;
  ::google::protobuf::int32 booking_holding_time_;
  ::google::protobuf::int32 alert_time_;
  ::google::protobuf::int32 off_delay_time_;
  ::google::protobuf::int32 min_off_time_;
  ::google::protobuf::int32 alert_current_;
  ::std::string* client_software_update_version_;
  ::google::protobuf::int32 booking_break_time_;
  bool loosemode_;
  ::std::string* working_time_;
  ::std::string* terimgurl_;
  ::google::protobuf::int32 bookingmodelid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static InstrumentDetail* default_instance_;
};
// -------------------------------------------------------------------

class Reservation : public ::google::protobuf::MessageLite {
 public:
  Reservation();
  virtual ~Reservation();

  Reservation(const Reservation& from);

  inline Reservation& operator=(const Reservation& from) {
    CopyFrom(from);
    return *this;
  }

  static const Reservation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Reservation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Reservation* other);

  // implements Message ----------------------------------------------

  Reservation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Reservation& from);
  void MergeFrom(const Reservation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::int32 group_id() const;
  inline void set_group_id(::google::protobuf::int32 value);

  // required int32 week = 3;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 3;
  inline ::google::protobuf::int32 week() const;
  inline void set_week(::google::protobuf::int32 value);

  // required int32 start_time = 4;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 4;
  inline ::google::protobuf::int32 start_time() const;
  inline void set_start_time(::google::protobuf::int32 value);

  // required int32 end_time = 5;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 5;
  inline ::google::protobuf::int32 end_time() const;
  inline void set_end_time(::google::protobuf::int32 value);

  // required int32 active_time = 6;
  inline bool has_active_time() const;
  inline void clear_active_time();
  static const int kActiveTimeFieldNumber = 6;
  inline ::google::protobuf::int32 active_time() const;
  inline void set_active_time(::google::protobuf::int32 value);

  // required int32 expire_time = 7;
  inline bool has_expire_time() const;
  inline void clear_expire_time();
  static const int kExpireTimeFieldNumber = 7;
  inline ::google::protobuf::int32 expire_time() const;
  inline void set_expire_time(::google::protobuf::int32 value);

  // optional int32 delete_time = 8;
  inline bool has_delete_time() const;
  inline void clear_delete_time();
  static const int kDeleteTimeFieldNumber = 8;
  inline ::google::protobuf::int32 delete_time() const;
  inline void set_delete_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.Reservation)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_active_time();
  inline void clear_has_active_time();
  inline void set_has_expire_time();
  inline void clear_has_expire_time();
  inline void set_has_delete_time();
  inline void clear_has_delete_time();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 group_id_;
  ::google::protobuf::int32 week_;
  ::google::protobuf::int32 start_time_;
  ::google::protobuf::int32 end_time_;
  ::google::protobuf::int32 active_time_;
  ::google::protobuf::int32 expire_time_;
  ::google::protobuf::int32 delete_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Reservation* default_instance_;
};
// -------------------------------------------------------------------

class ReservationList : public ::google::protobuf::MessageLite {
 public:
  ReservationList();
  virtual ~ReservationList();

  ReservationList(const ReservationList& from);

  inline ReservationList& operator=(const ReservationList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReservationList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReservationList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReservationList* other);

  // implements Message ----------------------------------------------

  ReservationList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReservationList& from);
  void MergeFrom(const ReservationList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.Reservation reservation = 1;
  inline int reservation_size() const;
  inline void clear_reservation();
  static const int kReservationFieldNumber = 1;
  inline const ::biotech::osla::Reservation& reservation(int index) const;
  inline ::biotech::osla::Reservation* mutable_reservation(int index);
  inline ::biotech::osla::Reservation* add_reservation();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Reservation >&
      reservation() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Reservation >*
      mutable_reservation();

  // @@protoc_insertion_point(class_scope:biotech.osla.ReservationList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::Reservation > reservation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ReservationList* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::MessageLite {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  static const User& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const User* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // required string first_name = 3;
  inline bool has_first_name() const;
  inline void clear_first_name();
  static const int kFirstNameFieldNumber = 3;
  inline const ::std::string& first_name() const;
  inline void set_first_name(const ::std::string& value);
  inline void set_first_name(const char* value);
  inline void set_first_name(const char* value, size_t size);
  inline ::std::string* mutable_first_name();
  inline ::std::string* release_first_name();
  inline void set_allocated_first_name(::std::string* first_name);

  // required string last_name = 4;
  inline bool has_last_name() const;
  inline void clear_last_name();
  static const int kLastNameFieldNumber = 4;
  inline const ::std::string& last_name() const;
  inline void set_last_name(const ::std::string& value);
  inline void set_last_name(const char* value);
  inline void set_last_name(const char* value, size_t size);
  inline ::std::string* mutable_last_name();
  inline ::std::string* release_last_name();
  inline void set_allocated_last_name(::std::string* last_name);

  // required string phone = 5;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 5;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string card_serial = 6;
  inline bool has_card_serial() const;
  inline void clear_card_serial();
  static const int kCardSerialFieldNumber = 6;
  inline const ::std::string& card_serial() const;
  inline void set_card_serial(const ::std::string& value);
  inline void set_card_serial(const char* value);
  inline void set_card_serial(const char* value, size_t size);
  inline ::std::string* mutable_card_serial();
  inline ::std::string* release_card_serial();
  inline void set_allocated_card_serial(::std::string* card_serial);

  // optional int32 account_id = 7;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 7;
  inline ::google::protobuf::int32 account_id() const;
  inline void set_account_id(::google::protobuf::int32 value);

  // required int32 isblack = 8;
  inline bool has_isblack() const;
  inline void clear_isblack();
  static const int kIsblackFieldNumber = 8;
  inline ::google::protobuf::int32 isblack() const;
  inline void set_isblack(::google::protobuf::int32 value);

  // optional int32 penaltyStopStart = 9;
  inline bool has_penaltystopstart() const;
  inline void clear_penaltystopstart();
  static const int kPenaltyStopStartFieldNumber = 9;
  inline ::google::protobuf::int32 penaltystopstart() const;
  inline void set_penaltystopstart(::google::protobuf::int32 value);

  // optional int32 penaltyStopEnd = 10;
  inline bool has_penaltystopend() const;
  inline void clear_penaltystopend();
  static const int kPenaltyStopEndFieldNumber = 10;
  inline ::google::protobuf::int32 penaltystopend() const;
  inline void set_penaltystopend(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.User)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_first_name();
  inline void clear_has_first_name();
  inline void set_has_last_name();
  inline void clear_has_last_name();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_card_serial();
  inline void clear_has_card_serial();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_isblack();
  inline void clear_has_isblack();
  inline void set_has_penaltystopstart();
  inline void clear_has_penaltystopstart();
  inline void set_has_penaltystopend();
  inline void clear_has_penaltystopend();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 status_;
  ::std::string* first_name_;
  ::std::string* last_name_;
  ::std::string* phone_;
  ::std::string* card_serial_;
  ::google::protobuf::int32 account_id_;
  ::google::protobuf::int32 isblack_;
  ::google::protobuf::int32 penaltystopstart_;
  ::google::protobuf::int32 penaltystopend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::MessageLite {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserList* other);

  // implements Message ----------------------------------------------

  UserList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.User user = 1;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::biotech::osla::User& user(int index) const;
  inline ::biotech::osla::User* mutable_user(int index);
  inline ::biotech::osla::User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::User >*
      mutable_user();

  // @@protoc_insertion_point(class_scope:biotech.osla.UserList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::User > user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UserList* default_instance_;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::MessageLite {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  static const Account& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Account* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  Account* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // required int32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::int32 group_id() const;
  inline void set_group_id(::google::protobuf::int32 value);

  // required int32 deposit = 4;
  inline bool has_deposit() const;
  inline void clear_deposit();
  static const int kDepositFieldNumber = 4;
  inline ::google::protobuf::int32 deposit() const;
  inline void set_deposit(::google::protobuf::int32 value);

  // required int32 credit = 5;
  inline bool has_credit() const;
  inline void clear_credit();
  static const int kCreditFieldNumber = 5;
  inline ::google::protobuf::int32 credit() const;
  inline void set_credit(::google::protobuf::int32 value);

  // required int32 credit_temp = 6;
  inline bool has_credit_temp() const;
  inline void clear_credit_temp();
  static const int kCreditTempFieldNumber = 6;
  inline ::google::protobuf::int32 credit_temp() const;
  inline void set_credit_temp(::google::protobuf::int32 value);

  // required int32 credit_temp_expire_time = 7;
  inline bool has_credit_temp_expire_time() const;
  inline void clear_credit_temp_expire_time();
  static const int kCreditTempExpireTimeFieldNumber = 7;
  inline ::google::protobuf::int32 credit_temp_expire_time() const;
  inline void set_credit_temp_expire_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.Account)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_deposit();
  inline void clear_has_deposit();
  inline void set_has_credit();
  inline void clear_has_credit();
  inline void set_has_credit_temp();
  inline void clear_has_credit_temp();
  inline void set_has_credit_temp_expire_time();
  inline void clear_has_credit_temp_expire_time();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 group_id_;
  ::google::protobuf::int32 deposit_;
  ::google::protobuf::int32 credit_;
  ::google::protobuf::int32 credit_temp_;
  ::google::protobuf::int32 credit_temp_expire_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class AccountList : public ::google::protobuf::MessageLite {
 public:
  AccountList();
  virtual ~AccountList();

  AccountList(const AccountList& from);

  inline AccountList& operator=(const AccountList& from) {
    CopyFrom(from);
    return *this;
  }

  static const AccountList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AccountList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AccountList* other);

  // implements Message ----------------------------------------------

  AccountList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AccountList& from);
  void MergeFrom(const AccountList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.Account accout = 1;
  inline int accout_size() const;
  inline void clear_accout();
  static const int kAccoutFieldNumber = 1;
  inline const ::biotech::osla::Account& accout(int index) const;
  inline ::biotech::osla::Account* mutable_accout(int index);
  inline ::biotech::osla::Account* add_accout();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Account >&
      accout() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Account >*
      mutable_accout();

  // @@protoc_insertion_point(class_scope:biotech.osla.AccountList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::Account > accout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static AccountList* default_instance_;
};
// -------------------------------------------------------------------

class UserRight : public ::google::protobuf::MessageLite {
 public:
  UserRight();
  virtual ~UserRight();

  UserRight(const UserRight& from);

  inline UserRight& operator=(const UserRight& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserRight& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserRight* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserRight* other);

  // implements Message ----------------------------------------------

  UserRight* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserRight& from);
  void MergeFrom(const UserRight& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required int32 right_temp = 3;
  inline bool has_right_temp() const;
  inline void clear_right_temp();
  static const int kRightTempFieldNumber = 3;
  inline ::google::protobuf::int32 right_temp() const;
  inline void set_right_temp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.UserRight)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_right_temp();
  inline void clear_has_right_temp();

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 right_temp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UserRight* default_instance_;
};
// -------------------------------------------------------------------

class UserRightList : public ::google::protobuf::MessageLite {
 public:
  UserRightList();
  virtual ~UserRightList();

  UserRightList(const UserRightList& from);

  inline UserRightList& operator=(const UserRightList& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserRightList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserRightList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserRightList* other);

  // implements Message ----------------------------------------------

  UserRightList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserRightList& from);
  void MergeFrom(const UserRightList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.UserRight user_right = 1;
  inline int user_right_size() const;
  inline void clear_user_right();
  static const int kUserRightFieldNumber = 1;
  inline const ::biotech::osla::UserRight& user_right(int index) const;
  inline ::biotech::osla::UserRight* mutable_user_right(int index);
  inline ::biotech::osla::UserRight* add_user_right();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserRight >&
      user_right() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserRight >*
      mutable_user_right();

  // @@protoc_insertion_point(class_scope:biotech.osla.UserRightList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserRight > user_right_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UserRightList* default_instance_;
};
// -------------------------------------------------------------------

class TempCardBinding : public ::google::protobuf::MessageLite {
 public:
  TempCardBinding();
  virtual ~TempCardBinding();

  TempCardBinding(const TempCardBinding& from);

  inline TempCardBinding& operator=(const TempCardBinding& from) {
    CopyFrom(from);
    return *this;
  }

  static const TempCardBinding& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TempCardBinding* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TempCardBinding* other);

  // implements Message ----------------------------------------------

  TempCardBinding* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TempCardBinding& from);
  void MergeFrom(const TempCardBinding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string card_serial = 1;
  inline bool has_card_serial() const;
  inline void clear_card_serial();
  static const int kCardSerialFieldNumber = 1;
  inline const ::std::string& card_serial() const;
  inline void set_card_serial(const ::std::string& value);
  inline void set_card_serial(const char* value);
  inline void set_card_serial(const char* value, size_t size);
  inline ::std::string* mutable_card_serial();
  inline ::std::string* release_card_serial();
  inline void set_allocated_card_serial(::std::string* card_serial);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 active_time = 3;
  inline bool has_active_time() const;
  inline void clear_active_time();
  static const int kActiveTimeFieldNumber = 3;
  inline ::google::protobuf::int32 active_time() const;
  inline void set_active_time(::google::protobuf::int32 value);

  // required int32 expire_time = 4;
  inline bool has_expire_time() const;
  inline void clear_expire_time();
  static const int kExpireTimeFieldNumber = 4;
  inline ::google::protobuf::int32 expire_time() const;
  inline void set_expire_time(::google::protobuf::int32 value);

  // optional int32 id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.TempCardBinding)
 private:
  inline void set_has_card_serial();
  inline void clear_has_card_serial();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_active_time();
  inline void clear_has_active_time();
  inline void set_has_expire_time();
  inline void clear_has_expire_time();
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string* card_serial_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 active_time_;
  ::google::protobuf::int32 expire_time_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TempCardBinding* default_instance_;
};
// -------------------------------------------------------------------

class TempCardBindingList : public ::google::protobuf::MessageLite {
 public:
  TempCardBindingList();
  virtual ~TempCardBindingList();

  TempCardBindingList(const TempCardBindingList& from);

  inline TempCardBindingList& operator=(const TempCardBindingList& from) {
    CopyFrom(from);
    return *this;
  }

  static const TempCardBindingList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TempCardBindingList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TempCardBindingList* other);

  // implements Message ----------------------------------------------

  TempCardBindingList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TempCardBindingList& from);
  void MergeFrom(const TempCardBindingList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.TempCardBinding temp_card_binding = 1;
  inline int temp_card_binding_size() const;
  inline void clear_temp_card_binding();
  static const int kTempCardBindingFieldNumber = 1;
  inline const ::biotech::osla::TempCardBinding& temp_card_binding(int index) const;
  inline ::biotech::osla::TempCardBinding* mutable_temp_card_binding(int index);
  inline ::biotech::osla::TempCardBinding* add_temp_card_binding();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::TempCardBinding >&
      temp_card_binding() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::TempCardBinding >*
      mutable_temp_card_binding();

  // @@protoc_insertion_point(class_scope:biotech.osla.TempCardBindingList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::TempCardBinding > temp_card_binding_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TempCardBindingList* default_instance_;
};
// -------------------------------------------------------------------

class Booking : public ::google::protobuf::MessageLite {
 public:
  Booking();
  virtual ~Booking();

  Booking(const Booking& from);

  inline Booking& operator=(const Booking& from) {
    CopyFrom(from);
    return *this;
  }

  static const Booking& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Booking* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Booking* other);

  // implements Message ----------------------------------------------

  Booking* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Booking& from);
  void MergeFrom(const Booking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::int32 start_time() const;
  inline void set_start_time(::google::protobuf::int32 value);

  // required int32 end_time = 4;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  inline ::google::protobuf::int32 end_time() const;
  inline void set_end_time(::google::protobuf::int32 value);

  // required int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional bool isTips = 7;
  inline bool has_istips() const;
  inline void clear_istips();
  static const int kIsTipsFieldNumber = 7;
  inline bool istips() const;
  inline void set_istips(bool value);

  // optional bool isEnd = 8;
  inline bool has_isend() const;
  inline void clear_isend();
  static const int kIsEndFieldNumber = 8;
  inline bool isend() const;
  inline void set_isend(bool value);

  // @@protoc_insertion_point(class_scope:biotech.osla.Booking)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_istips();
  inline void clear_has_istips();
  inline void set_has_isend();
  inline void clear_has_isend();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 start_time_;
  ::google::protobuf::int32 end_time_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 status_;
  bool istips_;
  bool isend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Booking* default_instance_;
};
// -------------------------------------------------------------------

class BookingList : public ::google::protobuf::MessageLite {
 public:
  BookingList();
  virtual ~BookingList();

  BookingList(const BookingList& from);

  inline BookingList& operator=(const BookingList& from) {
    CopyFrom(from);
    return *this;
  }

  static const BookingList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BookingList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BookingList* other);

  // implements Message ----------------------------------------------

  BookingList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BookingList& from);
  void MergeFrom(const BookingList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.Booking booking = 1;
  inline int booking_size() const;
  inline void clear_booking();
  static const int kBookingFieldNumber = 1;
  inline const ::biotech::osla::Booking& booking(int index) const;
  inline ::biotech::osla::Booking* mutable_booking(int index);
  inline ::biotech::osla::Booking* add_booking();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Booking >&
      booking() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Booking >*
      mutable_booking();

  // @@protoc_insertion_point(class_scope:biotech.osla.BookingList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::Booking > booking_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static BookingList* default_instance_;
};
// -------------------------------------------------------------------

class Calendar : public ::google::protobuf::MessageLite {
 public:
  Calendar();
  virtual ~Calendar();

  Calendar(const Calendar& from);

  inline Calendar& operator=(const Calendar& from) {
    CopyFrom(from);
    return *this;
  }

  static const Calendar& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Calendar* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Calendar* other);

  // implements Message ----------------------------------------------

  Calendar* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Calendar& from);
  void MergeFrom(const Calendar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 day = 1;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 1;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // required bool is_holiday = 2;
  inline bool has_is_holiday() const;
  inline void clear_is_holiday();
  static const int kIsHolidayFieldNumber = 2;
  inline bool is_holiday() const;
  inline void set_is_holiday(bool value);

  // optional int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.Calendar)
 private:
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_is_holiday();
  inline void clear_has_is_holiday();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 day_;
  bool is_holiday_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Calendar* default_instance_;
};
// -------------------------------------------------------------------

class CalendarList : public ::google::protobuf::MessageLite {
 public:
  CalendarList();
  virtual ~CalendarList();

  CalendarList(const CalendarList& from);

  inline CalendarList& operator=(const CalendarList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CalendarList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CalendarList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CalendarList* other);

  // implements Message ----------------------------------------------

  CalendarList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CalendarList& from);
  void MergeFrom(const CalendarList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.Calendar calendar = 1;
  inline int calendar_size() const;
  inline void clear_calendar();
  static const int kCalendarFieldNumber = 1;
  inline const ::biotech::osla::Calendar& calendar(int index) const;
  inline ::biotech::osla::Calendar* mutable_calendar(int index);
  inline ::biotech::osla::Calendar* add_calendar();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Calendar >&
      calendar() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Calendar >*
      mutable_calendar();

  // @@protoc_insertion_point(class_scope:biotech.osla.CalendarList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::Calendar > calendar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static CalendarList* default_instance_;
};
// -------------------------------------------------------------------

class GlobalConfig : public ::google::protobuf::MessageLite {
 public:
  GlobalConfig();
  virtual ~GlobalConfig();

  GlobalConfig(const GlobalConfig& from);

  inline GlobalConfig& operator=(const GlobalConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const GlobalConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GlobalConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GlobalConfig* other);

  // implements Message ----------------------------------------------

  GlobalConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GlobalConfig& from);
  void MergeFrom(const GlobalConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 account_deposit_limit = 1;
  inline bool has_account_deposit_limit() const;
  inline void clear_account_deposit_limit();
  static const int kAccountDepositLimitFieldNumber = 1;
  inline ::google::protobuf::int32 account_deposit_limit() const;
  inline void set_account_deposit_limit(::google::protobuf::int32 value);

  // optional string ftp_host = 2;
  inline bool has_ftp_host() const;
  inline void clear_ftp_host();
  static const int kFtpHostFieldNumber = 2;
  inline const ::std::string& ftp_host() const;
  inline void set_ftp_host(const ::std::string& value);
  inline void set_ftp_host(const char* value);
  inline void set_ftp_host(const char* value, size_t size);
  inline ::std::string* mutable_ftp_host();
  inline ::std::string* release_ftp_host();
  inline void set_allocated_ftp_host(::std::string* ftp_host);

  // optional string ftp_port = 3;
  inline bool has_ftp_port() const;
  inline void clear_ftp_port();
  static const int kFtpPortFieldNumber = 3;
  inline const ::std::string& ftp_port() const;
  inline void set_ftp_port(const ::std::string& value);
  inline void set_ftp_port(const char* value);
  inline void set_ftp_port(const char* value, size_t size);
  inline ::std::string* mutable_ftp_port();
  inline ::std::string* release_ftp_port();
  inline void set_allocated_ftp_port(::std::string* ftp_port);

  // optional string ftp_user_name = 4;
  inline bool has_ftp_user_name() const;
  inline void clear_ftp_user_name();
  static const int kFtpUserNameFieldNumber = 4;
  inline const ::std::string& ftp_user_name() const;
  inline void set_ftp_user_name(const ::std::string& value);
  inline void set_ftp_user_name(const char* value);
  inline void set_ftp_user_name(const char* value, size_t size);
  inline ::std::string* mutable_ftp_user_name();
  inline ::std::string* release_ftp_user_name();
  inline void set_allocated_ftp_user_name(::std::string* ftp_user_name);

  // optional string ftp_passwd = 5;
  inline bool has_ftp_passwd() const;
  inline void clear_ftp_passwd();
  static const int kFtpPasswdFieldNumber = 5;
  inline const ::std::string& ftp_passwd() const;
  inline void set_ftp_passwd(const ::std::string& value);
  inline void set_ftp_passwd(const char* value);
  inline void set_ftp_passwd(const char* value, size_t size);
  inline ::std::string* mutable_ftp_passwd();
  inline ::std::string* release_ftp_passwd();
  inline void set_allocated_ftp_passwd(::std::string* ftp_passwd);

  // optional string ftp_root_url = 6;
  inline bool has_ftp_root_url() const;
  inline void clear_ftp_root_url();
  static const int kFtpRootUrlFieldNumber = 6;
  inline const ::std::string& ftp_root_url() const;
  inline void set_ftp_root_url(const ::std::string& value);
  inline void set_ftp_root_url(const char* value);
  inline void set_ftp_root_url(const char* value, size_t size);
  inline ::std::string* mutable_ftp_root_url();
  inline ::std::string* release_ftp_root_url();
  inline void set_allocated_ftp_root_url(::std::string* ftp_root_url);

  // optional int32 ServiceTime = 7;
  inline bool has_servicetime() const;
  inline void clear_servicetime();
  static const int kServiceTimeFieldNumber = 7;
  inline ::google::protobuf::int32 servicetime() const;
  inline void set_servicetime(::google::protobuf::int32 value);

  // optional int32 CaptureTime = 8;
  inline bool has_capturetime() const;
  inline void clear_capturetime();
  static const int kCaptureTimeFieldNumber = 8;
  inline ::google::protobuf::int32 capturetime() const;
  inline void set_capturetime(::google::protobuf::int32 value);

  // optional string working_time = 9;
  inline bool has_working_time() const;
  inline void clear_working_time();
  static const int kWorkingTimeFieldNumber = 9;
  inline const ::std::string& working_time() const;
  inline void set_working_time(const ::std::string& value);
  inline void set_working_time(const char* value);
  inline void set_working_time(const char* value, size_t size);
  inline ::std::string* mutable_working_time();
  inline ::std::string* release_working_time();
  inline void set_allocated_working_time(::std::string* working_time);

  // optional bool payment_account_enable = 10;
  inline bool has_payment_account_enable() const;
  inline void clear_payment_account_enable();
  static const int kPaymentAccountEnableFieldNumber = 10;
  inline bool payment_account_enable() const;
  inline void set_payment_account_enable(bool value);

  // optional string value1 = 11;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 11;
  inline const ::std::string& value1() const;
  inline void set_value1(const ::std::string& value);
  inline void set_value1(const char* value);
  inline void set_value1(const char* value, size_t size);
  inline ::std::string* mutable_value1();
  inline ::std::string* release_value1();
  inline void set_allocated_value1(::std::string* value1);

  // optional string value2 = 12;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 12;
  inline const ::std::string& value2() const;
  inline void set_value2(const ::std::string& value);
  inline void set_value2(const char* value);
  inline void set_value2(const char* value, size_t size);
  inline ::std::string* mutable_value2();
  inline ::std::string* release_value2();
  inline void set_allocated_value2(::std::string* value2);

  // optional string value3 = 13;
  inline bool has_value3() const;
  inline void clear_value3();
  static const int kValue3FieldNumber = 13;
  inline const ::std::string& value3() const;
  inline void set_value3(const ::std::string& value);
  inline void set_value3(const char* value);
  inline void set_value3(const char* value, size_t size);
  inline ::std::string* mutable_value3();
  inline ::std::string* release_value3();
  inline void set_allocated_value3(::std::string* value3);

  // optional string value4 = 14;
  inline bool has_value4() const;
  inline void clear_value4();
  static const int kValue4FieldNumber = 14;
  inline const ::std::string& value4() const;
  inline void set_value4(const ::std::string& value);
  inline void set_value4(const char* value);
  inline void set_value4(const char* value, size_t size);
  inline ::std::string* mutable_value4();
  inline ::std::string* release_value4();
  inline void set_allocated_value4(::std::string* value4);

  // optional string value5 = 15;
  inline bool has_value5() const;
  inline void clear_value5();
  static const int kValue5FieldNumber = 15;
  inline const ::std::string& value5() const;
  inline void set_value5(const ::std::string& value);
  inline void set_value5(const char* value);
  inline void set_value5(const char* value, size_t size);
  inline ::std::string* mutable_value5();
  inline ::std::string* release_value5();
  inline void set_allocated_value5(::std::string* value5);

  // optional string value6 = 16;
  inline bool has_value6() const;
  inline void clear_value6();
  static const int kValue6FieldNumber = 16;
  inline const ::std::string& value6() const;
  inline void set_value6(const ::std::string& value);
  inline void set_value6(const char* value);
  inline void set_value6(const char* value, size_t size);
  inline ::std::string* mutable_value6();
  inline ::std::string* release_value6();
  inline void set_allocated_value6(::std::string* value6);

  // @@protoc_insertion_point(class_scope:biotech.osla.GlobalConfig)
 private:
  inline void set_has_account_deposit_limit();
  inline void clear_has_account_deposit_limit();
  inline void set_has_ftp_host();
  inline void clear_has_ftp_host();
  inline void set_has_ftp_port();
  inline void clear_has_ftp_port();
  inline void set_has_ftp_user_name();
  inline void clear_has_ftp_user_name();
  inline void set_has_ftp_passwd();
  inline void clear_has_ftp_passwd();
  inline void set_has_ftp_root_url();
  inline void clear_has_ftp_root_url();
  inline void set_has_servicetime();
  inline void clear_has_servicetime();
  inline void set_has_capturetime();
  inline void clear_has_capturetime();
  inline void set_has_working_time();
  inline void clear_has_working_time();
  inline void set_has_payment_account_enable();
  inline void clear_has_payment_account_enable();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_value3();
  inline void clear_has_value3();
  inline void set_has_value4();
  inline void clear_has_value4();
  inline void set_has_value5();
  inline void clear_has_value5();
  inline void set_has_value6();
  inline void clear_has_value6();

  ::std::string* ftp_host_;
  ::std::string* ftp_port_;
  ::std::string* ftp_user_name_;
  ::google::protobuf::int32 account_deposit_limit_;
  ::google::protobuf::int32 servicetime_;
  ::std::string* ftp_passwd_;
  ::std::string* ftp_root_url_;
  ::std::string* working_time_;
  ::google::protobuf::int32 capturetime_;
  bool payment_account_enable_;
  ::std::string* value1_;
  ::std::string* value2_;
  ::std::string* value3_;
  ::std::string* value4_;
  ::std::string* value5_;
  ::std::string* value6_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static GlobalConfig* default_instance_;
};
// -------------------------------------------------------------------

class Session : public ::google::protobuf::MessageLite {
 public:
  Session();
  virtual ~Session();

  Session(const Session& from);

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }

  static const Session& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Session* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Session* other);

  // implements Message ----------------------------------------------

  Session* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required int32 start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::int32 start_time() const;
  inline void set_start_time(::google::protobuf::int32 value);

  // required int32 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::int32 end_time() const;
  inline void set_end_time(::google::protobuf::int32 value);

  // required int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 user_id = 5;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 5;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required string card_serial = 6;
  inline bool has_card_serial() const;
  inline void clear_card_serial();
  static const int kCardSerialFieldNumber = 6;
  inline const ::std::string& card_serial() const;
  inline void set_card_serial(const ::std::string& value);
  inline void set_card_serial(const char* value);
  inline void set_card_serial(const char* value, size_t size);
  inline ::std::string* mutable_card_serial();
  inline ::std::string* release_card_serial();
  inline void set_allocated_card_serial(::std::string* card_serial);

  // required int32 user_right = 7;
  inline bool has_user_right() const;
  inline void clear_user_right();
  static const int kUserRightFieldNumber = 7;
  inline ::google::protobuf::int32 user_right() const;
  inline void set_user_right(::google::protobuf::int32 value);

  // required int32 account_id = 8;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 8;
  inline ::google::protobuf::int32 account_id() const;
  inline void set_account_id(::google::protobuf::int32 value);

  // required int32 group_id = 9;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 9;
  inline ::google::protobuf::int32 group_id() const;
  inline void set_group_id(::google::protobuf::int32 value);

  // optional int32 booking_id = 10;
  inline bool has_booking_id() const;
  inline void clear_booking_id();
  static const int kBookingIdFieldNumber = 10;
  inline ::google::protobuf::int32 booking_id() const;
  inline void set_booking_id(::google::protobuf::int32 value);

  // required bool penalty_flag = 11;
  inline bool has_penalty_flag() const;
  inline void clear_penalty_flag();
  static const int kPenaltyFlagFieldNumber = 11;
  inline bool penalty_flag() const;
  inline void set_penalty_flag(bool value);

  // required int32 instrument_id = 12;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 12;
  inline ::google::protobuf::int32 instrument_id() const;
  inline void set_instrument_id(::google::protobuf::int32 value);

  // optional int32 long_time_right = 13;
  inline bool has_long_time_right() const;
  inline void clear_long_time_right();
  static const int kLongTimeRightFieldNumber = 13;
  inline ::google::protobuf::int32 long_time_right() const;
  inline void set_long_time_right(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.Session)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_card_serial();
  inline void clear_has_card_serial();
  inline void set_has_user_right();
  inline void clear_has_user_right();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_booking_id();
  inline void clear_has_booking_id();
  inline void set_has_penalty_flag();
  inline void clear_has_penalty_flag();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_long_time_right();
  inline void clear_has_long_time_right();

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 start_time_;
  ::google::protobuf::int32 end_time_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 user_id_;
  ::std::string* card_serial_;
  ::google::protobuf::int32 user_right_;
  ::google::protobuf::int32 account_id_;
  ::google::protobuf::int32 group_id_;
  ::google::protobuf::int32 booking_id_;
  bool penalty_flag_;
  ::google::protobuf::int32 instrument_id_;
  ::google::protobuf::int32 long_time_right_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Session* default_instance_;
};
// -------------------------------------------------------------------

class SessionList : public ::google::protobuf::MessageLite {
 public:
  SessionList();
  virtual ~SessionList();

  SessionList(const SessionList& from);

  inline SessionList& operator=(const SessionList& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SessionList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SessionList* other);

  // implements Message ----------------------------------------------

  SessionList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SessionList& from);
  void MergeFrom(const SessionList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.Session session = 1;
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::biotech::osla::Session& session(int index) const;
  inline ::biotech::osla::Session* mutable_session(int index);
  inline ::biotech::osla::Session* add_session();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Session >&
      session() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Session >*
      mutable_session();

  // @@protoc_insertion_point(class_scope:biotech.osla.SessionList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::Session > session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SessionList* default_instance_;
};
// -------------------------------------------------------------------

class UserInTraining : public ::google::protobuf::MessageLite {
 public:
  UserInTraining();
  virtual ~UserInTraining();

  UserInTraining(const UserInTraining& from);

  inline UserInTraining& operator=(const UserInTraining& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserInTraining& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInTraining* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInTraining* other);

  // implements Message ----------------------------------------------

  UserInTraining* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInTraining& from);
  void MergeFrom(const UserInTraining& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 session_id() const;
  inline void set_session_id(::google::protobuf::int64 value);

  // required string card_serial = 2;
  inline bool has_card_serial() const;
  inline void clear_card_serial();
  static const int kCardSerialFieldNumber = 2;
  inline const ::std::string& card_serial() const;
  inline void set_card_serial(const ::std::string& value);
  inline void set_card_serial(const char* value);
  inline void set_card_serial(const char* value, size_t size);
  inline ::std::string* mutable_card_serial();
  inline ::std::string* release_card_serial();
  inline void set_allocated_card_serial(::std::string* card_serial);

  // required int32 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 check_in_time = 4;
  inline bool has_check_in_time() const;
  inline void clear_check_in_time();
  static const int kCheckInTimeFieldNumber = 4;
  inline ::google::protobuf::int32 check_in_time() const;
  inline void set_check_in_time(::google::protobuf::int32 value);

  // optional int32 rowid = 5;
  inline bool has_rowid() const;
  inline void clear_rowid();
  static const int kRowidFieldNumber = 5;
  inline ::google::protobuf::int32 rowid() const;
  inline void set_rowid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.UserInTraining)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_card_serial();
  inline void clear_has_card_serial();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_check_in_time();
  inline void clear_has_check_in_time();
  inline void set_has_rowid();
  inline void clear_has_rowid();

  ::google::protobuf::int64 session_id_;
  ::std::string* card_serial_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 check_in_time_;
  ::google::protobuf::int32 rowid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UserInTraining* default_instance_;
};
// -------------------------------------------------------------------

class UserInTrainingList : public ::google::protobuf::MessageLite {
 public:
  UserInTrainingList();
  virtual ~UserInTrainingList();

  UserInTrainingList(const UserInTrainingList& from);

  inline UserInTrainingList& operator=(const UserInTrainingList& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserInTrainingList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInTrainingList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInTrainingList* other);

  // implements Message ----------------------------------------------

  UserInTrainingList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInTrainingList& from);
  void MergeFrom(const UserInTrainingList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.UserInTraining user_in_training = 1;
  inline int user_in_training_size() const;
  inline void clear_user_in_training();
  static const int kUserInTrainingFieldNumber = 1;
  inline const ::biotech::osla::UserInTraining& user_in_training(int index) const;
  inline ::biotech::osla::UserInTraining* mutable_user_in_training(int index);
  inline ::biotech::osla::UserInTraining* add_user_in_training();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserInTraining >&
      user_in_training() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserInTraining >*
      mutable_user_in_training();

  // @@protoc_insertion_point(class_scope:biotech.osla.UserInTrainingList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserInTraining > user_in_training_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UserInTrainingList* default_instance_;
};
// -------------------------------------------------------------------

class UserEvent : public ::google::protobuf::MessageLite {
 public:
  UserEvent();
  virtual ~UserEvent();

  UserEvent(const UserEvent& from);

  inline UserEvent& operator=(const UserEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserEvent* other);

  // implements Message ----------------------------------------------

  UserEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserEvent& from);
  void MergeFrom(const UserEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // optional int32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::int32 group_id() const;
  inline void set_group_id(::google::protobuf::int32 value);

  // required string card_serial = 4;
  inline bool has_card_serial() const;
  inline void clear_card_serial();
  static const int kCardSerialFieldNumber = 4;
  inline const ::std::string& card_serial() const;
  inline void set_card_serial(const ::std::string& value);
  inline void set_card_serial(const char* value);
  inline void set_card_serial(const char* value, size_t size);
  inline ::std::string* mutable_card_serial();
  inline ::std::string* release_card_serial();
  inline void set_allocated_card_serial(::std::string* card_serial);

  // required int32 card_type = 5;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 5;
  inline ::google::protobuf::int32 card_type() const;
  inline void set_card_type(::google::protobuf::int32 value);

  // required int32 action_type = 6;
  inline bool has_action_type() const;
  inline void clear_action_type();
  static const int kActionTypeFieldNumber = 6;
  inline ::google::protobuf::int32 action_type() const;
  inline void set_action_type(::google::protobuf::int32 value);

  // required int32 action_result = 7;
  inline bool has_action_result() const;
  inline void clear_action_result();
  static const int kActionResultFieldNumber = 7;
  inline ::google::protobuf::int32 action_result() const;
  inline void set_action_result(::google::protobuf::int32 value);

  // required int32 create_time = 8;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 8;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // required int32 instrument_id = 9;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 9;
  inline ::google::protobuf::int32 instrument_id() const;
  inline void set_instrument_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.UserEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_card_serial();
  inline void clear_has_card_serial();
  inline void set_has_card_type();
  inline void clear_has_card_type();
  inline void set_has_action_type();
  inline void clear_has_action_type();
  inline void set_has_action_result();
  inline void clear_has_action_result();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 group_id_;
  ::std::string* card_serial_;
  ::google::protobuf::int32 card_type_;
  ::google::protobuf::int32 action_type_;
  ::google::protobuf::int32 action_result_;
  ::google::protobuf::int32 create_time_;
  ::google::protobuf::int32 instrument_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UserEvent* default_instance_;
};
// -------------------------------------------------------------------

class UserEventList : public ::google::protobuf::MessageLite {
 public:
  UserEventList();
  virtual ~UserEventList();

  UserEventList(const UserEventList& from);

  inline UserEventList& operator=(const UserEventList& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserEventList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserEventList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserEventList* other);

  // implements Message ----------------------------------------------

  UserEventList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserEventList& from);
  void MergeFrom(const UserEventList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.UserEvent user_event = 1;
  inline int user_event_size() const;
  inline void clear_user_event();
  static const int kUserEventFieldNumber = 1;
  inline const ::biotech::osla::UserEvent& user_event(int index) const;
  inline ::biotech::osla::UserEvent* mutable_user_event(int index);
  inline ::biotech::osla::UserEvent* add_user_event();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserEvent >&
      user_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserEvent >*
      mutable_user_event();

  // @@protoc_insertion_point(class_scope:biotech.osla.UserEventList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserEvent > user_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UserEventList* default_instance_;
};
// -------------------------------------------------------------------

class SystemEvent : public ::google::protobuf::MessageLite {
 public:
  SystemEvent();
  virtual ~SystemEvent();

  SystemEvent(const SystemEvent& from);

  inline SystemEvent& operator=(const SystemEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const SystemEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SystemEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SystemEvent* other);

  // implements Message ----------------------------------------------

  SystemEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SystemEvent& from);
  void MergeFrom(const SystemEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required int32 event_type = 2;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 2;
  inline ::google::protobuf::int32 event_type() const;
  inline void set_event_type(::google::protobuf::int32 value);

  // optional int64 event_content = 3;
  inline bool has_event_content() const;
  inline void clear_event_content();
  static const int kEventContentFieldNumber = 3;
  inline ::google::protobuf::int64 event_content() const;
  inline void set_event_content(::google::protobuf::int64 value);

  // required int32 create_time = 4;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 4;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // required int32 instrument_id = 5;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 5;
  inline ::google::protobuf::int32 instrument_id() const;
  inline void set_instrument_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.SystemEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_event_content();
  inline void clear_has_event_content();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();

  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 event_content_;
  ::google::protobuf::int32 event_type_;
  ::google::protobuf::int32 create_time_;
  ::google::protobuf::int32 instrument_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SystemEvent* default_instance_;
};
// -------------------------------------------------------------------

class SystemEventList : public ::google::protobuf::MessageLite {
 public:
  SystemEventList();
  virtual ~SystemEventList();

  SystemEventList(const SystemEventList& from);

  inline SystemEventList& operator=(const SystemEventList& from) {
    CopyFrom(from);
    return *this;
  }

  static const SystemEventList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SystemEventList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SystemEventList* other);

  // implements Message ----------------------------------------------

  SystemEventList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SystemEventList& from);
  void MergeFrom(const SystemEventList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.SystemEvent system_event = 1;
  inline int system_event_size() const;
  inline void clear_system_event();
  static const int kSystemEventFieldNumber = 1;
  inline const ::biotech::osla::SystemEvent& system_event(int index) const;
  inline ::biotech::osla::SystemEvent* mutable_system_event(int index);
  inline ::biotech::osla::SystemEvent* add_system_event();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::SystemEvent >&
      system_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::SystemEvent >*
      mutable_system_event();

  // @@protoc_insertion_point(class_scope:biotech.osla.SystemEventList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::SystemEvent > system_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SystemEventList* default_instance_;
};
// -------------------------------------------------------------------

class FtpFileUpload : public ::google::protobuf::MessageLite {
 public:
  FtpFileUpload();
  virtual ~FtpFileUpload();

  FtpFileUpload(const FtpFileUpload& from);

  inline FtpFileUpload& operator=(const FtpFileUpload& from) {
    CopyFrom(from);
    return *this;
  }

  static const FtpFileUpload& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FtpFileUpload* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FtpFileUpload* other);

  // implements Message ----------------------------------------------

  FtpFileUpload* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FtpFileUpload& from);
  void MergeFrom(const FtpFileUpload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required .biotech.osla.FTP_FILE_UPLOAD_STATUS status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::biotech::osla::FTP_FILE_UPLOAD_STATUS status() const;
  inline void set_status(::biotech::osla::FTP_FILE_UPLOAD_STATUS value);

  // required int32 consume_time = 4;
  inline bool has_consume_time() const;
  inline void clear_consume_time();
  static const int kConsumeTimeFieldNumber = 4;
  inline ::google::protobuf::int32 consume_time() const;
  inline void set_consume_time(::google::protobuf::int32 value);

  // required int64 file_size = 5;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 5;
  inline ::google::protobuf::int64 file_size() const;
  inline void set_file_size(::google::protobuf::int64 value);

  // required string create_time = 6;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  inline const ::std::string& create_time() const;
  inline void set_create_time(const ::std::string& value);
  inline void set_create_time(const char* value);
  inline void set_create_time(const char* value, size_t size);
  inline ::std::string* mutable_create_time();
  inline ::std::string* release_create_time();
  inline void set_allocated_create_time(::std::string* create_time);

  // optional int32 percentage = 7;
  inline bool has_percentage() const;
  inline void clear_percentage();
  static const int kPercentageFieldNumber = 7;
  inline ::google::protobuf::int32 percentage() const;
  inline void set_percentage(::google::protobuf::int32 value);

  // optional int32 localid = 8;
  inline bool has_localid() const;
  inline void clear_localid();
  static const int kLocalidFieldNumber = 8;
  inline ::google::protobuf::int32 localid() const;
  inline void set_localid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.FtpFileUpload)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_consume_time();
  inline void clear_has_consume_time();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_percentage();
  inline void clear_has_percentage();
  inline void set_has_localid();
  inline void clear_has_localid();

  ::std::string* path_;
  ::std::string* file_name_;
  int status_;
  ::google::protobuf::int32 consume_time_;
  ::google::protobuf::int64 file_size_;
  ::std::string* create_time_;
  ::google::protobuf::int32 percentage_;
  ::google::protobuf::int32 localid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static FtpFileUpload* default_instance_;
};
// -------------------------------------------------------------------

class FtpEvent : public ::google::protobuf::MessageLite {
 public:
  FtpEvent();
  virtual ~FtpEvent();

  FtpEvent(const FtpEvent& from);

  inline FtpEvent& operator=(const FtpEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const FtpEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FtpEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FtpEvent* other);

  // implements Message ----------------------------------------------

  FtpEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FtpEvent& from);
  void MergeFrom(const FtpEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 instrument_id = 3;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 3;
  inline ::google::protobuf::int32 instrument_id() const;
  inline void set_instrument_id(::google::protobuf::int32 value);

  // required int32 group_id = 4;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 4;
  inline ::google::protobuf::int32 group_id() const;
  inline void set_group_id(::google::protobuf::int32 value);

  // required int32 actived_account = 5;
  inline bool has_actived_account() const;
  inline void clear_actived_account();
  static const int kActivedAccountFieldNumber = 5;
  inline ::google::protobuf::int32 actived_account() const;
  inline void set_actived_account(::google::protobuf::int32 value);

  // repeated .biotech.osla.FtpFileUpload file = 6;
  inline int file_size() const;
  inline void clear_file();
  static const int kFileFieldNumber = 6;
  inline const ::biotech::osla::FtpFileUpload& file(int index) const;
  inline ::biotech::osla::FtpFileUpload* mutable_file(int index);
  inline ::biotech::osla::FtpFileUpload* add_file();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpFileUpload >&
      file() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpFileUpload >*
      mutable_file();

  // optional int32 localId = 7;
  inline bool has_localid() const;
  inline void clear_localid();
  static const int kLocalIdFieldNumber = 7;
  inline ::google::protobuf::int32 localid() const;
  inline void set_localid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.FtpEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_actived_account();
  inline void clear_has_actived_account();
  inline void set_has_localid();
  inline void clear_has_localid();

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 instrument_id_;
  ::google::protobuf::int32 group_id_;
  ::google::protobuf::int32 actived_account_;
  ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpFileUpload > file_;
  ::google::protobuf::int32 localid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static FtpEvent* default_instance_;
};
// -------------------------------------------------------------------

class FtpEventList : public ::google::protobuf::MessageLite {
 public:
  FtpEventList();
  virtual ~FtpEventList();

  FtpEventList(const FtpEventList& from);

  inline FtpEventList& operator=(const FtpEventList& from) {
    CopyFrom(from);
    return *this;
  }

  static const FtpEventList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FtpEventList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FtpEventList* other);

  // implements Message ----------------------------------------------

  FtpEventList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FtpEventList& from);
  void MergeFrom(const FtpEventList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.FtpEvent ftp_event = 1;
  inline int ftp_event_size() const;
  inline void clear_ftp_event();
  static const int kFtpEventFieldNumber = 1;
  inline const ::biotech::osla::FtpEvent& ftp_event(int index) const;
  inline ::biotech::osla::FtpEvent* mutable_ftp_event(int index);
  inline ::biotech::osla::FtpEvent* add_ftp_event();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpEvent >&
      ftp_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpEvent >*
      mutable_ftp_event();

  // @@protoc_insertion_point(class_scope:biotech.osla.FtpEventList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpEvent > ftp_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static FtpEventList* default_instance_;
};
// -------------------------------------------------------------------

class DeviceCaptureEvent : public ::google::protobuf::MessageLite {
 public:
  DeviceCaptureEvent();
  virtual ~DeviceCaptureEvent();

  DeviceCaptureEvent(const DeviceCaptureEvent& from);

  inline DeviceCaptureEvent& operator=(const DeviceCaptureEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceCaptureEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceCaptureEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceCaptureEvent* other);

  // implements Message ----------------------------------------------

  DeviceCaptureEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceCaptureEvent& from);
  void MergeFrom(const DeviceCaptureEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required int32 instrumentId = 2;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentIdFieldNumber = 2;
  inline ::google::protobuf::int32 instrumentid() const;
  inline void set_instrumentid(::google::protobuf::int32 value);

  // required string deviceName = 3;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 3;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  inline void set_allocated_devicename(::std::string* devicename);

  // required string deviceValue = 4;
  inline bool has_devicevalue() const;
  inline void clear_devicevalue();
  static const int kDeviceValueFieldNumber = 4;
  inline const ::std::string& devicevalue() const;
  inline void set_devicevalue(const ::std::string& value);
  inline void set_devicevalue(const char* value);
  inline void set_devicevalue(const char* value, size_t size);
  inline ::std::string* mutable_devicevalue();
  inline ::std::string* release_devicevalue();
  inline void set_allocated_devicevalue(::std::string* devicevalue);

  // required int32 captureTime = 5;
  inline bool has_capturetime() const;
  inline void clear_capturetime();
  static const int kCaptureTimeFieldNumber = 5;
  inline ::google::protobuf::int32 capturetime() const;
  inline void set_capturetime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.DeviceCaptureEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_devicename();
  inline void clear_has_devicename();
  inline void set_has_devicevalue();
  inline void clear_has_devicevalue();
  inline void set_has_capturetime();
  inline void clear_has_capturetime();

  ::google::protobuf::int64 id_;
  ::std::string* devicename_;
  ::google::protobuf::int32 instrumentid_;
  ::google::protobuf::int32 capturetime_;
  ::std::string* devicevalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static DeviceCaptureEvent* default_instance_;
};
// -------------------------------------------------------------------

class DeviceCaptureEventList : public ::google::protobuf::MessageLite {
 public:
  DeviceCaptureEventList();
  virtual ~DeviceCaptureEventList();

  DeviceCaptureEventList(const DeviceCaptureEventList& from);

  inline DeviceCaptureEventList& operator=(const DeviceCaptureEventList& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceCaptureEventList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceCaptureEventList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceCaptureEventList* other);

  // implements Message ----------------------------------------------

  DeviceCaptureEventList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceCaptureEventList& from);
  void MergeFrom(const DeviceCaptureEventList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.DeviceCaptureEvent device_capture_event = 1;
  inline int device_capture_event_size() const;
  inline void clear_device_capture_event();
  static const int kDeviceCaptureEventFieldNumber = 1;
  inline const ::biotech::osla::DeviceCaptureEvent& device_capture_event(int index) const;
  inline ::biotech::osla::DeviceCaptureEvent* mutable_device_capture_event(int index);
  inline ::biotech::osla::DeviceCaptureEvent* add_device_capture_event();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::DeviceCaptureEvent >&
      device_capture_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::DeviceCaptureEvent >*
      mutable_device_capture_event();

  // @@protoc_insertion_point(class_scope:biotech.osla.DeviceCaptureEventList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::DeviceCaptureEvent > device_capture_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static DeviceCaptureEventList* default_instance_;
};
// -------------------------------------------------------------------

class SessionOpertaionReq : public ::google::protobuf::MessageLite {
 public:
  SessionOpertaionReq();
  virtual ~SessionOpertaionReq();

  SessionOpertaionReq(const SessionOpertaionReq& from);

  inline SessionOpertaionReq& operator=(const SessionOpertaionReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionOpertaionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SessionOpertaionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SessionOpertaionReq* other);

  // implements Message ----------------------------------------------

  SessionOpertaionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SessionOpertaionReq& from);
  void MergeFrom(const SessionOpertaionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required string card_serial = 3;
  inline bool has_card_serial() const;
  inline void clear_card_serial();
  static const int kCardSerialFieldNumber = 3;
  inline const ::std::string& card_serial() const;
  inline void set_card_serial(const ::std::string& value);
  inline void set_card_serial(const char* value);
  inline void set_card_serial(const char* value, size_t size);
  inline ::std::string* mutable_card_serial();
  inline ::std::string* release_card_serial();
  inline void set_allocated_card_serial(::std::string* card_serial);

  // required int32 user_role = 4;
  inline bool has_user_role() const;
  inline void clear_user_role();
  static const int kUserRoleFieldNumber = 4;
  inline ::google::protobuf::int32 user_role() const;
  inline void set_user_role(::google::protobuf::int32 value);

  // required int32 operation_type = 5;
  inline bool has_operation_type() const;
  inline void clear_operation_type();
  static const int kOperationTypeFieldNumber = 5;
  inline ::google::protobuf::int32 operation_type() const;
  inline void set_operation_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.SessionOpertaionReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_card_serial();
  inline void clear_has_card_serial();
  inline void set_has_user_role();
  inline void clear_has_user_role();
  inline void set_has_operation_type();
  inline void clear_has_operation_type();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 user_id_;
  ::std::string* card_serial_;
  ::google::protobuf::int32 user_role_;
  ::google::protobuf::int32 operation_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SessionOpertaionReq* default_instance_;
};
// -------------------------------------------------------------------

class SessionOpertaionRep : public ::google::protobuf::MessageLite {
 public:
  SessionOpertaionRep();
  virtual ~SessionOpertaionRep();

  SessionOpertaionRep(const SessionOpertaionRep& from);

  inline SessionOpertaionRep& operator=(const SessionOpertaionRep& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionOpertaionRep& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SessionOpertaionRep* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SessionOpertaionRep* other);

  // implements Message ----------------------------------------------

  SessionOpertaionRep* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SessionOpertaionRep& from);
  void MergeFrom(const SessionOpertaionRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // required int32 BookingId = 3;
  inline bool has_bookingid() const;
  inline void clear_bookingid();
  static const int kBookingIdFieldNumber = 3;
  inline ::google::protobuf::int32 bookingid() const;
  inline void set_bookingid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.SessionOpertaionRep)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_bookingid();
  inline void clear_has_bookingid();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 bookingid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SessionOpertaionRep* default_instance_;
};
// -------------------------------------------------------------------

class Entrust : public ::google::protobuf::MessageLite {
 public:
  Entrust();
  virtual ~Entrust();

  Entrust(const Entrust& from);

  inline Entrust& operator=(const Entrust& from) {
    CopyFrom(from);
    return *this;
  }

  static const Entrust& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Entrust* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Entrust* other);

  // implements Message ----------------------------------------------

  Entrust* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Entrust& from);
  void MergeFrom(const Entrust& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // required int32 is_doing = 5;
  inline bool has_is_doing() const;
  inline void clear_is_doing();
  static const int kIsDoingFieldNumber = 5;
  inline ::google::protobuf::int32 is_doing() const;
  inline void set_is_doing(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:biotech.osla.Entrust)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_is_doing();
  inline void clear_has_is_doing();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 user_id_;
  ::std::string* title_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 is_doing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Entrust* default_instance_;
};
// -------------------------------------------------------------------

class EntrustList : public ::google::protobuf::MessageLite {
 public:
  EntrustList();
  virtual ~EntrustList();

  EntrustList(const EntrustList& from);

  inline EntrustList& operator=(const EntrustList& from) {
    CopyFrom(from);
    return *this;
  }

  static const EntrustList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EntrustList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EntrustList* other);

  // implements Message ----------------------------------------------

  EntrustList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EntrustList& from);
  void MergeFrom(const EntrustList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.Entrust entrust = 1;
  inline int entrust_size() const;
  inline void clear_entrust();
  static const int kEntrustFieldNumber = 1;
  inline const ::biotech::osla::Entrust& entrust(int index) const;
  inline ::biotech::osla::Entrust* mutable_entrust(int index);
  inline ::biotech::osla::Entrust* add_entrust();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Entrust >&
      entrust() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Entrust >*
      mutable_entrust();

  // @@protoc_insertion_point(class_scope:biotech.osla.EntrustList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::Entrust > entrust_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static EntrustList* default_instance_;
};
// -------------------------------------------------------------------

class EntrustEvent : public ::google::protobuf::MessageLite {
 public:
  EntrustEvent();
  virtual ~EntrustEvent();

  EntrustEvent(const EntrustEvent& from);

  inline EntrustEvent& operator=(const EntrustEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const EntrustEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EntrustEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EntrustEvent* other);

  // implements Message ----------------------------------------------

  EntrustEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EntrustEvent& from);
  void MergeFrom(const EntrustEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required int32 entrust_id = 2;
  inline bool has_entrust_id() const;
  inline void clear_entrust_id();
  static const int kEntrustIdFieldNumber = 2;
  inline ::google::protobuf::int32 entrust_id() const;
  inline void set_entrust_id(::google::protobuf::int32 value);

  // required int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional int32 is_doing = 4;
  inline bool has_is_doing() const;
  inline void clear_is_doing();
  static const int kIsDoingFieldNumber = 4;
  inline ::google::protobuf::int32 is_doing() const;
  inline void set_is_doing(::google::protobuf::int32 value);

  // required int64 session_id = 5;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 5;
  inline ::google::protobuf::int64 session_id() const;
  inline void set_session_id(::google::protobuf::int64 value);

  // optional .biotech.osla.Session sessionInfo = 6;
  inline bool has_sessioninfo() const;
  inline void clear_sessioninfo();
  static const int kSessionInfoFieldNumber = 6;
  inline const ::biotech::osla::Session& sessioninfo() const;
  inline ::biotech::osla::Session* mutable_sessioninfo();
  inline ::biotech::osla::Session* release_sessioninfo();
  inline void set_allocated_sessioninfo(::biotech::osla::Session* sessioninfo);

  // @@protoc_insertion_point(class_scope:biotech.osla.EntrustEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_entrust_id();
  inline void clear_has_entrust_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_is_doing();
  inline void clear_has_is_doing();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_sessioninfo();
  inline void clear_has_sessioninfo();

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 entrust_id_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int64 session_id_;
  ::biotech::osla::Session* sessioninfo_;
  ::google::protobuf::int32 is_doing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static EntrustEvent* default_instance_;
};
// -------------------------------------------------------------------

class EntrustEventList : public ::google::protobuf::MessageLite {
 public:
  EntrustEventList();
  virtual ~EntrustEventList();

  EntrustEventList(const EntrustEventList& from);

  inline EntrustEventList& operator=(const EntrustEventList& from) {
    CopyFrom(from);
    return *this;
  }

  static const EntrustEventList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EntrustEventList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EntrustEventList* other);

  // implements Message ----------------------------------------------

  EntrustEventList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EntrustEventList& from);
  void MergeFrom(const EntrustEventList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .biotech.osla.EntrustEvent entrust_event = 1;
  inline int entrust_event_size() const;
  inline void clear_entrust_event();
  static const int kEntrustEventFieldNumber = 1;
  inline const ::biotech::osla::EntrustEvent& entrust_event(int index) const;
  inline ::biotech::osla::EntrustEvent* mutable_entrust_event(int index);
  inline ::biotech::osla::EntrustEvent* add_entrust_event();
  inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::EntrustEvent >&
      entrust_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::EntrustEvent >*
      mutable_entrust_event();

  // @@protoc_insertion_point(class_scope:biotech.osla.EntrustEventList)
 private:

  ::google::protobuf::RepeatedPtrField< ::biotech::osla::EntrustEvent > entrust_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static EntrustEventList* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeParams : public ::google::protobuf::MessageLite {
 public:
  UpgradeParams();
  virtual ~UpgradeParams();

  UpgradeParams(const UpgradeParams& from);

  inline UpgradeParams& operator=(const UpgradeParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpgradeParams& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpgradeParams* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpgradeParams* other);

  // implements Message ----------------------------------------------

  UpgradeParams* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpgradeParams& from);
  void MergeFrom(const UpgradeParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // required bool force_upgrade = 2;
  inline bool has_force_upgrade() const;
  inline void clear_force_upgrade();
  static const int kForceUpgradeFieldNumber = 2;
  inline bool force_upgrade() const;
  inline void set_force_upgrade(bool value);

  // required string new_ver = 3;
  inline bool has_new_ver() const;
  inline void clear_new_ver();
  static const int kNewVerFieldNumber = 3;
  inline const ::std::string& new_ver() const;
  inline void set_new_ver(const ::std::string& value);
  inline void set_new_ver(const char* value);
  inline void set_new_ver(const char* value, size_t size);
  inline ::std::string* mutable_new_ver();
  inline ::std::string* release_new_ver();
  inline void set_allocated_new_ver(::std::string* new_ver);

  // required string from_ver = 4;
  inline bool has_from_ver() const;
  inline void clear_from_ver();
  static const int kFromVerFieldNumber = 4;
  inline const ::std::string& from_ver() const;
  inline void set_from_ver(const ::std::string& value);
  inline void set_from_ver(const char* value);
  inline void set_from_ver(const char* value, size_t size);
  inline ::std::string* mutable_from_ver();
  inline ::std::string* release_from_ver();
  inline void set_allocated_from_ver(::std::string* from_ver);

  // required int32 size = 5;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 5;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // required int32 adler32 = 6;
  inline bool has_adler32() const;
  inline void clear_adler32();
  static const int kAdler32FieldNumber = 6;
  inline ::google::protobuf::int32 adler32() const;
  inline void set_adler32(::google::protobuf::int32 value);

  // required string url = 7;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 7;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string reversed1 = 8;
  inline bool has_reversed1() const;
  inline void clear_reversed1();
  static const int kReversed1FieldNumber = 8;
  inline const ::std::string& reversed1() const;
  inline void set_reversed1(const ::std::string& value);
  inline void set_reversed1(const char* value);
  inline void set_reversed1(const char* value, size_t size);
  inline ::std::string* mutable_reversed1();
  inline ::std::string* release_reversed1();
  inline void set_allocated_reversed1(::std::string* reversed1);

  // optional string reversed2 = 9;
  inline bool has_reversed2() const;
  inline void clear_reversed2();
  static const int kReversed2FieldNumber = 9;
  inline const ::std::string& reversed2() const;
  inline void set_reversed2(const ::std::string& value);
  inline void set_reversed2(const char* value);
  inline void set_reversed2(const char* value, size_t size);
  inline ::std::string* mutable_reversed2();
  inline ::std::string* release_reversed2();
  inline void set_allocated_reversed2(::std::string* reversed2);

  // @@protoc_insertion_point(class_scope:biotech.osla.UpgradeParams)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_force_upgrade();
  inline void clear_has_force_upgrade();
  inline void set_has_new_ver();
  inline void clear_has_new_ver();
  inline void set_has_from_ver();
  inline void clear_has_from_ver();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_adler32();
  inline void clear_has_adler32();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_reversed1();
  inline void clear_has_reversed1();
  inline void set_has_reversed2();
  inline void clear_has_reversed2();

  bool enable_;
  bool force_upgrade_;
  ::google::protobuf::int32 size_;
  ::std::string* new_ver_;
  ::std::string* from_ver_;
  ::std::string* url_;
  ::std::string* reversed1_;
  ::std::string* reversed2_;
  ::google::protobuf::int32 adler32_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UpgradeParams* default_instance_;
};
// -------------------------------------------------------------------

class UpgradePlan : public ::google::protobuf::MessageLite {
 public:
  UpgradePlan();
  virtual ~UpgradePlan();

  UpgradePlan(const UpgradePlan& from);

  inline UpgradePlan& operator=(const UpgradePlan& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpgradePlan& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpgradePlan* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpgradePlan* other);

  // implements Message ----------------------------------------------

  UpgradePlan* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpgradePlan& from);
  void MergeFrom(const UpgradePlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int64 start_date = 2;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 2;
  inline ::google::protobuf::int64 start_date() const;
  inline void set_start_date(::google::protobuf::int64 value);

  // required int32 interval = 3;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 3;
  inline ::google::protobuf::int32 interval() const;
  inline void set_interval(::google::protobuf::int32 value);

  // optional string reversed1 = 4;
  inline bool has_reversed1() const;
  inline void clear_reversed1();
  static const int kReversed1FieldNumber = 4;
  inline const ::std::string& reversed1() const;
  inline void set_reversed1(const ::std::string& value);
  inline void set_reversed1(const char* value);
  inline void set_reversed1(const char* value, size_t size);
  inline ::std::string* mutable_reversed1();
  inline ::std::string* release_reversed1();
  inline void set_allocated_reversed1(::std::string* reversed1);

  // @@protoc_insertion_point(class_scope:biotech.osla.UpgradePlan)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_reversed1();
  inline void clear_has_reversed1();

  ::google::protobuf::int64 start_date_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 interval_;
  ::std::string* reversed1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UpgradePlan* default_instance_;
};
// ===================================================================


// ===================================================================

// TinsQuaList

// repeated .biotech.osla.TinsQuaConfig tinsQuas = 1;
inline int TinsQuaList::tinsquas_size() const {
  return tinsquas_.size();
}
inline void TinsQuaList::clear_tinsquas() {
  tinsquas_.Clear();
}
inline const ::biotech::osla::TinsQuaConfig& TinsQuaList::tinsquas(int index) const {
  return tinsquas_.Get(index);
}
inline ::biotech::osla::TinsQuaConfig* TinsQuaList::mutable_tinsquas(int index) {
  return tinsquas_.Mutable(index);
}
inline ::biotech::osla::TinsQuaConfig* TinsQuaList::add_tinsquas() {
  return tinsquas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::TinsQuaConfig >&
TinsQuaList::tinsquas() const {
  return tinsquas_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::TinsQuaConfig >*
TinsQuaList::mutable_tinsquas() {
  return &tinsquas_;
}

// -------------------------------------------------------------------

// TinsQuaConfig

// required int32 id = 1;
inline bool TinsQuaConfig::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TinsQuaConfig::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TinsQuaConfig::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TinsQuaConfig::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TinsQuaConfig::id() const {
  return id_;
}
inline void TinsQuaConfig::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required bool type = 2;
inline bool TinsQuaConfig::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TinsQuaConfig::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TinsQuaConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TinsQuaConfig::clear_type() {
  type_ = false;
  clear_has_type();
}
inline bool TinsQuaConfig::type() const {
  return type_;
}
inline void TinsQuaConfig::set_type(bool value) {
  set_has_type();
  type_ = value;
}

// optional string orgNum = 3;
inline bool TinsQuaConfig::has_orgnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TinsQuaConfig::set_has_orgnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TinsQuaConfig::clear_has_orgnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TinsQuaConfig::clear_orgnum() {
  if (orgnum_ != &::google::protobuf::internal::kEmptyString) {
    orgnum_->clear();
  }
  clear_has_orgnum();
}
inline const ::std::string& TinsQuaConfig::orgnum() const {
  return *orgnum_;
}
inline void TinsQuaConfig::set_orgnum(const ::std::string& value) {
  set_has_orgnum();
  if (orgnum_ == &::google::protobuf::internal::kEmptyString) {
    orgnum_ = new ::std::string;
  }
  orgnum_->assign(value);
}
inline void TinsQuaConfig::set_orgnum(const char* value) {
  set_has_orgnum();
  if (orgnum_ == &::google::protobuf::internal::kEmptyString) {
    orgnum_ = new ::std::string;
  }
  orgnum_->assign(value);
}
inline void TinsQuaConfig::set_orgnum(const char* value, size_t size) {
  set_has_orgnum();
  if (orgnum_ == &::google::protobuf::internal::kEmptyString) {
    orgnum_ = new ::std::string;
  }
  orgnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TinsQuaConfig::mutable_orgnum() {
  set_has_orgnum();
  if (orgnum_ == &::google::protobuf::internal::kEmptyString) {
    orgnum_ = new ::std::string;
  }
  return orgnum_;
}
inline ::std::string* TinsQuaConfig::release_orgnum() {
  clear_has_orgnum();
  if (orgnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orgnum_;
    orgnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TinsQuaConfig::set_allocated_orgnum(::std::string* orgnum) {
  if (orgnum_ != &::google::protobuf::internal::kEmptyString) {
    delete orgnum_;
  }
  if (orgnum) {
    set_has_orgnum();
    orgnum_ = orgnum;
  } else {
    clear_has_orgnum();
    orgnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 instrumentId = 4;
inline bool TinsQuaConfig::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TinsQuaConfig::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TinsQuaConfig::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TinsQuaConfig::clear_instrumentid() {
  instrumentid_ = 0;
  clear_has_instrumentid();
}
inline ::google::protobuf::int32 TinsQuaConfig::instrumentid() const {
  return instrumentid_;
}
inline void TinsQuaConfig::set_instrumentid(::google::protobuf::int32 value) {
  set_has_instrumentid();
  instrumentid_ = value;
}

// required int32 quaId = 5;
inline bool TinsQuaConfig::has_quaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TinsQuaConfig::set_has_quaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TinsQuaConfig::clear_has_quaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TinsQuaConfig::clear_quaid() {
  quaid_ = 0;
  clear_has_quaid();
}
inline ::google::protobuf::int32 TinsQuaConfig::quaid() const {
  return quaid_;
}
inline void TinsQuaConfig::set_quaid(::google::protobuf::int32 value) {
  set_has_quaid();
  quaid_ = value;
}

// required bool workTime = 6;
inline bool TinsQuaConfig::has_worktime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TinsQuaConfig::set_has_worktime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TinsQuaConfig::clear_has_worktime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TinsQuaConfig::clear_worktime() {
  worktime_ = false;
  clear_has_worktime();
}
inline bool TinsQuaConfig::worktime() const {
  return worktime_;
}
inline void TinsQuaConfig::set_worktime(bool value) {
  set_has_worktime();
  worktime_ = value;
}

// required int32 status = 7;
inline bool TinsQuaConfig::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TinsQuaConfig::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TinsQuaConfig::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TinsQuaConfig::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 TinsQuaConfig::status() const {
  return status_;
}
inline void TinsQuaConfig::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// Heartbeat

// required int32 client_timestamp = 1;
inline bool Heartbeat::has_client_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Heartbeat::set_has_client_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Heartbeat::clear_has_client_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Heartbeat::clear_client_timestamp() {
  client_timestamp_ = 0;
  clear_has_client_timestamp();
}
inline ::google::protobuf::int32 Heartbeat::client_timestamp() const {
  return client_timestamp_;
}
inline void Heartbeat::set_client_timestamp(::google::protobuf::int32 value) {
  set_has_client_timestamp();
  client_timestamp_ = value;
}

// required int32 server_timestamp = 2;
inline bool Heartbeat::has_server_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Heartbeat::set_has_server_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Heartbeat::clear_has_server_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Heartbeat::clear_server_timestamp() {
  server_timestamp_ = 0;
  clear_has_server_timestamp();
}
inline ::google::protobuf::int32 Heartbeat::server_timestamp() const {
  return server_timestamp_;
}
inline void Heartbeat::set_server_timestamp(::google::protobuf::int32 value) {
  set_has_server_timestamp();
  server_timestamp_ = value;
}

// optional int32 instrument_id = 3;
inline bool Heartbeat::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Heartbeat::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Heartbeat::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Heartbeat::clear_instrument_id() {
  instrument_id_ = 0;
  clear_has_instrument_id();
}
inline ::google::protobuf::int32 Heartbeat::instrument_id() const {
  return instrument_id_;
}
inline void Heartbeat::set_instrument_id(::google::protobuf::int32 value) {
  set_has_instrument_id();
  instrument_id_ = value;
}

// optional int32 client_state = 4;
inline bool Heartbeat::has_client_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Heartbeat::set_has_client_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Heartbeat::clear_has_client_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Heartbeat::clear_client_state() {
  client_state_ = 0;
  clear_has_client_state();
}
inline ::google::protobuf::int32 Heartbeat::client_state() const {
  return client_state_;
}
inline void Heartbeat::set_client_state(::google::protobuf::int32 value) {
  set_has_client_state();
  client_state_ = value;
}

// optional string org_code = 5;
inline bool Heartbeat::has_org_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Heartbeat::set_has_org_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Heartbeat::clear_has_org_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Heartbeat::clear_org_code() {
  if (org_code_ != &::google::protobuf::internal::kEmptyString) {
    org_code_->clear();
  }
  clear_has_org_code();
}
inline const ::std::string& Heartbeat::org_code() const {
  return *org_code_;
}
inline void Heartbeat::set_org_code(const ::std::string& value) {
  set_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    org_code_ = new ::std::string;
  }
  org_code_->assign(value);
}
inline void Heartbeat::set_org_code(const char* value) {
  set_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    org_code_ = new ::std::string;
  }
  org_code_->assign(value);
}
inline void Heartbeat::set_org_code(const char* value, size_t size) {
  set_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    org_code_ = new ::std::string;
  }
  org_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Heartbeat::mutable_org_code() {
  set_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    org_code_ = new ::std::string;
  }
  return org_code_;
}
inline ::std::string* Heartbeat::release_org_code() {
  clear_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = org_code_;
    org_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Heartbeat::set_allocated_org_code(::std::string* org_code) {
  if (org_code_ != &::google::protobuf::internal::kEmptyString) {
    delete org_code_;
  }
  if (org_code) {
    set_has_org_code();
    org_code_ = org_code;
  } else {
    clear_has_org_code();
    org_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InitPhase

// required .biotech.osla.InitPhase.Option option = 1;
inline bool InitPhase::has_option() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitPhase::set_has_option() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitPhase::clear_has_option() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitPhase::clear_option() {
  option_ = 1;
  clear_has_option();
}
inline ::biotech::osla::InitPhase_Option InitPhase::option() const {
  return static_cast< ::biotech::osla::InitPhase_Option >(option_);
}
inline void InitPhase::set_option(::biotech::osla::InitPhase_Option value) {
  assert(::biotech::osla::InitPhase_Option_IsValid(value));
  set_has_option();
  option_ = value;
}

// optional string bind_code = 2;
inline bool InitPhase::has_bind_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitPhase::set_has_bind_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitPhase::clear_has_bind_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitPhase::clear_bind_code() {
  if (bind_code_ != &::google::protobuf::internal::kEmptyString) {
    bind_code_->clear();
  }
  clear_has_bind_code();
}
inline const ::std::string& InitPhase::bind_code() const {
  return *bind_code_;
}
inline void InitPhase::set_bind_code(const ::std::string& value) {
  set_has_bind_code();
  if (bind_code_ == &::google::protobuf::internal::kEmptyString) {
    bind_code_ = new ::std::string;
  }
  bind_code_->assign(value);
}
inline void InitPhase::set_bind_code(const char* value) {
  set_has_bind_code();
  if (bind_code_ == &::google::protobuf::internal::kEmptyString) {
    bind_code_ = new ::std::string;
  }
  bind_code_->assign(value);
}
inline void InitPhase::set_bind_code(const char* value, size_t size) {
  set_has_bind_code();
  if (bind_code_ == &::google::protobuf::internal::kEmptyString) {
    bind_code_ = new ::std::string;
  }
  bind_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitPhase::mutable_bind_code() {
  set_has_bind_code();
  if (bind_code_ == &::google::protobuf::internal::kEmptyString) {
    bind_code_ = new ::std::string;
  }
  return bind_code_;
}
inline ::std::string* InitPhase::release_bind_code() {
  clear_has_bind_code();
  if (bind_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bind_code_;
    bind_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InitPhase::set_allocated_bind_code(::std::string* bind_code) {
  if (bind_code_ != &::google::protobuf::internal::kEmptyString) {
    delete bind_code_;
  }
  if (bind_code) {
    set_has_bind_code();
    bind_code_ = bind_code;
  } else {
    clear_has_bind_code();
    bind_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command

// required .biotech.osla.Command.Option option = 1;
inline bool Command::has_option() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_option() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_option() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_option() {
  option_ = 11;
  clear_has_option();
}
inline ::biotech::osla::Command_Option Command::option() const {
  return static_cast< ::biotech::osla::Command_Option >(option_);
}
inline void Command::set_option(::biotech::osla::Command_Option value) {
  assert(::biotech::osla::Command_Option_IsValid(value));
  set_has_option();
  option_ = value;
}

// -------------------------------------------------------------------

// Instrument

// required int32 id = 1;
inline bool Instrument::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Instrument::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Instrument::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Instrument::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Instrument::id() const {
  return id_;
}
inline void Instrument::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool Instrument::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Instrument::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Instrument::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Instrument::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Instrument::name() const {
  return *name_;
}
inline void Instrument::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Instrument::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Instrument::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Instrument::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string org_code = 3;
inline bool Instrument::has_org_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Instrument::set_has_org_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Instrument::clear_has_org_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Instrument::clear_org_code() {
  if (org_code_ != &::google::protobuf::internal::kEmptyString) {
    org_code_->clear();
  }
  clear_has_org_code();
}
inline const ::std::string& Instrument::org_code() const {
  return *org_code_;
}
inline void Instrument::set_org_code(const ::std::string& value) {
  set_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    org_code_ = new ::std::string;
  }
  org_code_->assign(value);
}
inline void Instrument::set_org_code(const char* value) {
  set_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    org_code_ = new ::std::string;
  }
  org_code_->assign(value);
}
inline void Instrument::set_org_code(const char* value, size_t size) {
  set_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    org_code_ = new ::std::string;
  }
  org_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_org_code() {
  set_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    org_code_ = new ::std::string;
  }
  return org_code_;
}
inline ::std::string* Instrument::release_org_code() {
  clear_has_org_code();
  if (org_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = org_code_;
    org_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_org_code(::std::string* org_code) {
  if (org_code_ != &::google::protobuf::internal::kEmptyString) {
    delete org_code_;
  }
  if (org_code) {
    set_has_org_code();
    org_code_ = org_code;
  } else {
    clear_has_org_code();
    org_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InstrumentList

// repeated .biotech.osla.Instrument instrument = 1;
inline int InstrumentList::instrument_size() const {
  return instrument_.size();
}
inline void InstrumentList::clear_instrument() {
  instrument_.Clear();
}
inline const ::biotech::osla::Instrument& InstrumentList::instrument(int index) const {
  return instrument_.Get(index);
}
inline ::biotech::osla::Instrument* InstrumentList::mutable_instrument(int index) {
  return instrument_.Mutable(index);
}
inline ::biotech::osla::Instrument* InstrumentList::add_instrument() {
  return instrument_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Instrument >&
InstrumentList::instrument() const {
  return instrument_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Instrument >*
InstrumentList::mutable_instrument() {
  return &instrument_;
}

// -------------------------------------------------------------------

// InstrumentBinding

// required int32 instrument_id = 1;
inline bool InstrumentBinding::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrumentBinding::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrumentBinding::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrumentBinding::clear_instrument_id() {
  instrument_id_ = 0;
  clear_has_instrument_id();
}
inline ::google::protobuf::int32 InstrumentBinding::instrument_id() const {
  return instrument_id_;
}
inline void InstrumentBinding::set_instrument_id(::google::protobuf::int32 value) {
  set_has_instrument_id();
  instrument_id_ = value;
}

// required string client_mac_addr = 2;
inline bool InstrumentBinding::has_client_mac_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrumentBinding::set_has_client_mac_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrumentBinding::clear_has_client_mac_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrumentBinding::clear_client_mac_addr() {
  if (client_mac_addr_ != &::google::protobuf::internal::kEmptyString) {
    client_mac_addr_->clear();
  }
  clear_has_client_mac_addr();
}
inline const ::std::string& InstrumentBinding::client_mac_addr() const {
  return *client_mac_addr_;
}
inline void InstrumentBinding::set_client_mac_addr(const ::std::string& value) {
  set_has_client_mac_addr();
  if (client_mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    client_mac_addr_ = new ::std::string;
  }
  client_mac_addr_->assign(value);
}
inline void InstrumentBinding::set_client_mac_addr(const char* value) {
  set_has_client_mac_addr();
  if (client_mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    client_mac_addr_ = new ::std::string;
  }
  client_mac_addr_->assign(value);
}
inline void InstrumentBinding::set_client_mac_addr(const char* value, size_t size) {
  set_has_client_mac_addr();
  if (client_mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    client_mac_addr_ = new ::std::string;
  }
  client_mac_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentBinding::mutable_client_mac_addr() {
  set_has_client_mac_addr();
  if (client_mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    client_mac_addr_ = new ::std::string;
  }
  return client_mac_addr_;
}
inline ::std::string* InstrumentBinding::release_client_mac_addr() {
  clear_has_client_mac_addr();
  if (client_mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_mac_addr_;
    client_mac_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentBinding::set_allocated_client_mac_addr(::std::string* client_mac_addr) {
  if (client_mac_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete client_mac_addr_;
  }
  if (client_mac_addr) {
    set_has_client_mac_addr();
    client_mac_addr_ = client_mac_addr;
  } else {
    clear_has_client_mac_addr();
    client_mac_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 client_model = 3;
inline bool InstrumentBinding::has_client_model() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrumentBinding::set_has_client_model() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrumentBinding::clear_has_client_model() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrumentBinding::clear_client_model() {
  client_model_ = 0;
  clear_has_client_model();
}
inline ::google::protobuf::int32 InstrumentBinding::client_model() const {
  return client_model_;
}
inline void InstrumentBinding::set_client_model(::google::protobuf::int32 value) {
  set_has_client_model();
  client_model_ = value;
}

// required string client_version = 4;
inline bool InstrumentBinding::has_client_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstrumentBinding::set_has_client_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstrumentBinding::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstrumentBinding::clear_client_version() {
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    client_version_->clear();
  }
  clear_has_client_version();
}
inline const ::std::string& InstrumentBinding::client_version() const {
  return *client_version_;
}
inline void InstrumentBinding::set_client_version(const ::std::string& value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
}
inline void InstrumentBinding::set_client_version(const char* value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
}
inline void InstrumentBinding::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentBinding::mutable_client_version() {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  return client_version_;
}
inline ::std::string* InstrumentBinding::release_client_version() {
  clear_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_version_;
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentBinding::set_allocated_client_version(::std::string* client_version) {
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    delete client_version_;
  }
  if (client_version) {
    set_has_client_version();
    client_version_ = client_version;
  } else {
    clear_has_client_version();
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .biotech.osla.InstrumentBinding.Option option = 5;
inline bool InstrumentBinding::has_option() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstrumentBinding::set_has_option() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstrumentBinding::clear_has_option() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstrumentBinding::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::biotech::osla::InstrumentBinding_Option InstrumentBinding::option() const {
  return static_cast< ::biotech::osla::InstrumentBinding_Option >(option_);
}
inline void InstrumentBinding::set_option(::biotech::osla::InstrumentBinding_Option value) {
  assert(::biotech::osla::InstrumentBinding_Option_IsValid(value));
  set_has_option();
  option_ = value;
}

// optional string bindCode = 6;
inline bool InstrumentBinding::has_bindcode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstrumentBinding::set_has_bindcode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstrumentBinding::clear_has_bindcode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstrumentBinding::clear_bindcode() {
  if (bindcode_ != &::google::protobuf::internal::kEmptyString) {
    bindcode_->clear();
  }
  clear_has_bindcode();
}
inline const ::std::string& InstrumentBinding::bindcode() const {
  return *bindcode_;
}
inline void InstrumentBinding::set_bindcode(const ::std::string& value) {
  set_has_bindcode();
  if (bindcode_ == &::google::protobuf::internal::kEmptyString) {
    bindcode_ = new ::std::string;
  }
  bindcode_->assign(value);
}
inline void InstrumentBinding::set_bindcode(const char* value) {
  set_has_bindcode();
  if (bindcode_ == &::google::protobuf::internal::kEmptyString) {
    bindcode_ = new ::std::string;
  }
  bindcode_->assign(value);
}
inline void InstrumentBinding::set_bindcode(const char* value, size_t size) {
  set_has_bindcode();
  if (bindcode_ == &::google::protobuf::internal::kEmptyString) {
    bindcode_ = new ::std::string;
  }
  bindcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentBinding::mutable_bindcode() {
  set_has_bindcode();
  if (bindcode_ == &::google::protobuf::internal::kEmptyString) {
    bindcode_ = new ::std::string;
  }
  return bindcode_;
}
inline ::std::string* InstrumentBinding::release_bindcode() {
  clear_has_bindcode();
  if (bindcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bindcode_;
    bindcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentBinding::set_allocated_bindcode(::std::string* bindcode) {
  if (bindcode_ != &::google::protobuf::internal::kEmptyString) {
    delete bindcode_;
  }
  if (bindcode) {
    set_has_bindcode();
    bindcode_ = bindcode;
  } else {
    clear_has_bindcode();
    bindcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InstrumentDetail

// required int32 id = 1;
inline bool InstrumentDetail::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrumentDetail::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrumentDetail::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrumentDetail::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 InstrumentDetail::id() const {
  return id_;
}
inline void InstrumentDetail::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool InstrumentDetail::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrumentDetail::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrumentDetail::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrumentDetail::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InstrumentDetail::name() const {
  return *name_;
}
inline void InstrumentDetail::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InstrumentDetail::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InstrumentDetail::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentDetail::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* InstrumentDetail::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentDetail::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 3;
inline bool InstrumentDetail::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrumentDetail::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrumentDetail::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrumentDetail::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 InstrumentDetail::status() const {
  return status_;
}
inline void InstrumentDetail::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int32 min_interval = 4;
inline bool InstrumentDetail::has_min_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstrumentDetail::set_has_min_interval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstrumentDetail::clear_has_min_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstrumentDetail::clear_min_interval() {
  min_interval_ = 0;
  clear_has_min_interval();
}
inline ::google::protobuf::int32 InstrumentDetail::min_interval() const {
  return min_interval_;
}
inline void InstrumentDetail::set_min_interval(::google::protobuf::int32 value) {
  set_has_min_interval();
  min_interval_ = value;
}

// required int32 booking_holding_time = 5;
inline bool InstrumentDetail::has_booking_holding_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstrumentDetail::set_has_booking_holding_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstrumentDetail::clear_has_booking_holding_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstrumentDetail::clear_booking_holding_time() {
  booking_holding_time_ = 0;
  clear_has_booking_holding_time();
}
inline ::google::protobuf::int32 InstrumentDetail::booking_holding_time() const {
  return booking_holding_time_;
}
inline void InstrumentDetail::set_booking_holding_time(::google::protobuf::int32 value) {
  set_has_booking_holding_time();
  booking_holding_time_ = value;
}

// required int32 alert_time = 6;
inline bool InstrumentDetail::has_alert_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstrumentDetail::set_has_alert_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstrumentDetail::clear_has_alert_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstrumentDetail::clear_alert_time() {
  alert_time_ = 0;
  clear_has_alert_time();
}
inline ::google::protobuf::int32 InstrumentDetail::alert_time() const {
  return alert_time_;
}
inline void InstrumentDetail::set_alert_time(::google::protobuf::int32 value) {
  set_has_alert_time();
  alert_time_ = value;
}

// optional int32 off_delay_time = 7;
inline bool InstrumentDetail::has_off_delay_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstrumentDetail::set_has_off_delay_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstrumentDetail::clear_has_off_delay_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstrumentDetail::clear_off_delay_time() {
  off_delay_time_ = 0;
  clear_has_off_delay_time();
}
inline ::google::protobuf::int32 InstrumentDetail::off_delay_time() const {
  return off_delay_time_;
}
inline void InstrumentDetail::set_off_delay_time(::google::protobuf::int32 value) {
  set_has_off_delay_time();
  off_delay_time_ = value;
}

// optional int32 min_off_time = 8;
inline bool InstrumentDetail::has_min_off_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstrumentDetail::set_has_min_off_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstrumentDetail::clear_has_min_off_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstrumentDetail::clear_min_off_time() {
  min_off_time_ = 0;
  clear_has_min_off_time();
}
inline ::google::protobuf::int32 InstrumentDetail::min_off_time() const {
  return min_off_time_;
}
inline void InstrumentDetail::set_min_off_time(::google::protobuf::int32 value) {
  set_has_min_off_time();
  min_off_time_ = value;
}

// optional int32 alert_current = 9;
inline bool InstrumentDetail::has_alert_current() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstrumentDetail::set_has_alert_current() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstrumentDetail::clear_has_alert_current() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstrumentDetail::clear_alert_current() {
  alert_current_ = 0;
  clear_has_alert_current();
}
inline ::google::protobuf::int32 InstrumentDetail::alert_current() const {
  return alert_current_;
}
inline void InstrumentDetail::set_alert_current(::google::protobuf::int32 value) {
  set_has_alert_current();
  alert_current_ = value;
}

// optional string client_software_update_version = 10;
inline bool InstrumentDetail::has_client_software_update_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstrumentDetail::set_has_client_software_update_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstrumentDetail::clear_has_client_software_update_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstrumentDetail::clear_client_software_update_version() {
  if (client_software_update_version_ != &::google::protobuf::internal::kEmptyString) {
    client_software_update_version_->clear();
  }
  clear_has_client_software_update_version();
}
inline const ::std::string& InstrumentDetail::client_software_update_version() const {
  return *client_software_update_version_;
}
inline void InstrumentDetail::set_client_software_update_version(const ::std::string& value) {
  set_has_client_software_update_version();
  if (client_software_update_version_ == &::google::protobuf::internal::kEmptyString) {
    client_software_update_version_ = new ::std::string;
  }
  client_software_update_version_->assign(value);
}
inline void InstrumentDetail::set_client_software_update_version(const char* value) {
  set_has_client_software_update_version();
  if (client_software_update_version_ == &::google::protobuf::internal::kEmptyString) {
    client_software_update_version_ = new ::std::string;
  }
  client_software_update_version_->assign(value);
}
inline void InstrumentDetail::set_client_software_update_version(const char* value, size_t size) {
  set_has_client_software_update_version();
  if (client_software_update_version_ == &::google::protobuf::internal::kEmptyString) {
    client_software_update_version_ = new ::std::string;
  }
  client_software_update_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentDetail::mutable_client_software_update_version() {
  set_has_client_software_update_version();
  if (client_software_update_version_ == &::google::protobuf::internal::kEmptyString) {
    client_software_update_version_ = new ::std::string;
  }
  return client_software_update_version_;
}
inline ::std::string* InstrumentDetail::release_client_software_update_version() {
  clear_has_client_software_update_version();
  if (client_software_update_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_software_update_version_;
    client_software_update_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentDetail::set_allocated_client_software_update_version(::std::string* client_software_update_version) {
  if (client_software_update_version_ != &::google::protobuf::internal::kEmptyString) {
    delete client_software_update_version_;
  }
  if (client_software_update_version) {
    set_has_client_software_update_version();
    client_software_update_version_ = client_software_update_version;
  } else {
    clear_has_client_software_update_version();
    client_software_update_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 booking_break_time = 11;
inline bool InstrumentDetail::has_booking_break_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstrumentDetail::set_has_booking_break_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstrumentDetail::clear_has_booking_break_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstrumentDetail::clear_booking_break_time() {
  booking_break_time_ = 0;
  clear_has_booking_break_time();
}
inline ::google::protobuf::int32 InstrumentDetail::booking_break_time() const {
  return booking_break_time_;
}
inline void InstrumentDetail::set_booking_break_time(::google::protobuf::int32 value) {
  set_has_booking_break_time();
  booking_break_time_ = value;
}

// optional bool looseMode = 12;
inline bool InstrumentDetail::has_loosemode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InstrumentDetail::set_has_loosemode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InstrumentDetail::clear_has_loosemode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InstrumentDetail::clear_loosemode() {
  loosemode_ = false;
  clear_has_loosemode();
}
inline bool InstrumentDetail::loosemode() const {
  return loosemode_;
}
inline void InstrumentDetail::set_loosemode(bool value) {
  set_has_loosemode();
  loosemode_ = value;
}

// optional string working_time = 13;
inline bool InstrumentDetail::has_working_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InstrumentDetail::set_has_working_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InstrumentDetail::clear_has_working_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InstrumentDetail::clear_working_time() {
  if (working_time_ != &::google::protobuf::internal::kEmptyString) {
    working_time_->clear();
  }
  clear_has_working_time();
}
inline const ::std::string& InstrumentDetail::working_time() const {
  return *working_time_;
}
inline void InstrumentDetail::set_working_time(const ::std::string& value) {
  set_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    working_time_ = new ::std::string;
  }
  working_time_->assign(value);
}
inline void InstrumentDetail::set_working_time(const char* value) {
  set_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    working_time_ = new ::std::string;
  }
  working_time_->assign(value);
}
inline void InstrumentDetail::set_working_time(const char* value, size_t size) {
  set_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    working_time_ = new ::std::string;
  }
  working_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentDetail::mutable_working_time() {
  set_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    working_time_ = new ::std::string;
  }
  return working_time_;
}
inline ::std::string* InstrumentDetail::release_working_time() {
  clear_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = working_time_;
    working_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentDetail::set_allocated_working_time(::std::string* working_time) {
  if (working_time_ != &::google::protobuf::internal::kEmptyString) {
    delete working_time_;
  }
  if (working_time) {
    set_has_working_time();
    working_time_ = working_time;
  } else {
    clear_has_working_time();
    working_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 bookingModelID = 14;
inline bool InstrumentDetail::has_bookingmodelid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InstrumentDetail::set_has_bookingmodelid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InstrumentDetail::clear_has_bookingmodelid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InstrumentDetail::clear_bookingmodelid() {
  bookingmodelid_ = 0;
  clear_has_bookingmodelid();
}
inline ::google::protobuf::int32 InstrumentDetail::bookingmodelid() const {
  return bookingmodelid_;
}
inline void InstrumentDetail::set_bookingmodelid(::google::protobuf::int32 value) {
  set_has_bookingmodelid();
  bookingmodelid_ = value;
}

// optional string terImgUrl = 15;
inline bool InstrumentDetail::has_terimgurl() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InstrumentDetail::set_has_terimgurl() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InstrumentDetail::clear_has_terimgurl() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InstrumentDetail::clear_terimgurl() {
  if (terimgurl_ != &::google::protobuf::internal::kEmptyString) {
    terimgurl_->clear();
  }
  clear_has_terimgurl();
}
inline const ::std::string& InstrumentDetail::terimgurl() const {
  return *terimgurl_;
}
inline void InstrumentDetail::set_terimgurl(const ::std::string& value) {
  set_has_terimgurl();
  if (terimgurl_ == &::google::protobuf::internal::kEmptyString) {
    terimgurl_ = new ::std::string;
  }
  terimgurl_->assign(value);
}
inline void InstrumentDetail::set_terimgurl(const char* value) {
  set_has_terimgurl();
  if (terimgurl_ == &::google::protobuf::internal::kEmptyString) {
    terimgurl_ = new ::std::string;
  }
  terimgurl_->assign(value);
}
inline void InstrumentDetail::set_terimgurl(const char* value, size_t size) {
  set_has_terimgurl();
  if (terimgurl_ == &::google::protobuf::internal::kEmptyString) {
    terimgurl_ = new ::std::string;
  }
  terimgurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentDetail::mutable_terimgurl() {
  set_has_terimgurl();
  if (terimgurl_ == &::google::protobuf::internal::kEmptyString) {
    terimgurl_ = new ::std::string;
  }
  return terimgurl_;
}
inline ::std::string* InstrumentDetail::release_terimgurl() {
  clear_has_terimgurl();
  if (terimgurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = terimgurl_;
    terimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentDetail::set_allocated_terimgurl(::std::string* terimgurl) {
  if (terimgurl_ != &::google::protobuf::internal::kEmptyString) {
    delete terimgurl_;
  }
  if (terimgurl) {
    set_has_terimgurl();
    terimgurl_ = terimgurl;
  } else {
    clear_has_terimgurl();
    terimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Reservation

// required int32 id = 1;
inline bool Reservation::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reservation::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reservation::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reservation::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Reservation::id() const {
  return id_;
}
inline void Reservation::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 group_id = 2;
inline bool Reservation::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reservation::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reservation::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reservation::clear_group_id() {
  group_id_ = 0;
  clear_has_group_id();
}
inline ::google::protobuf::int32 Reservation::group_id() const {
  return group_id_;
}
inline void Reservation::set_group_id(::google::protobuf::int32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required int32 week = 3;
inline bool Reservation::has_week() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reservation::set_has_week() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reservation::clear_has_week() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reservation::clear_week() {
  week_ = 0;
  clear_has_week();
}
inline ::google::protobuf::int32 Reservation::week() const {
  return week_;
}
inline void Reservation::set_week(::google::protobuf::int32 value) {
  set_has_week();
  week_ = value;
}

// required int32 start_time = 4;
inline bool Reservation::has_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reservation::set_has_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reservation::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reservation::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline ::google::protobuf::int32 Reservation::start_time() const {
  return start_time_;
}
inline void Reservation::set_start_time(::google::protobuf::int32 value) {
  set_has_start_time();
  start_time_ = value;
}

// required int32 end_time = 5;
inline bool Reservation::has_end_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reservation::set_has_end_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reservation::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reservation::clear_end_time() {
  end_time_ = 0;
  clear_has_end_time();
}
inline ::google::protobuf::int32 Reservation::end_time() const {
  return end_time_;
}
inline void Reservation::set_end_time(::google::protobuf::int32 value) {
  set_has_end_time();
  end_time_ = value;
}

// required int32 active_time = 6;
inline bool Reservation::has_active_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reservation::set_has_active_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reservation::clear_has_active_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reservation::clear_active_time() {
  active_time_ = 0;
  clear_has_active_time();
}
inline ::google::protobuf::int32 Reservation::active_time() const {
  return active_time_;
}
inline void Reservation::set_active_time(::google::protobuf::int32 value) {
  set_has_active_time();
  active_time_ = value;
}

// required int32 expire_time = 7;
inline bool Reservation::has_expire_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Reservation::set_has_expire_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Reservation::clear_has_expire_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Reservation::clear_expire_time() {
  expire_time_ = 0;
  clear_has_expire_time();
}
inline ::google::protobuf::int32 Reservation::expire_time() const {
  return expire_time_;
}
inline void Reservation::set_expire_time(::google::protobuf::int32 value) {
  set_has_expire_time();
  expire_time_ = value;
}

// optional int32 delete_time = 8;
inline bool Reservation::has_delete_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Reservation::set_has_delete_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Reservation::clear_has_delete_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Reservation::clear_delete_time() {
  delete_time_ = 0;
  clear_has_delete_time();
}
inline ::google::protobuf::int32 Reservation::delete_time() const {
  return delete_time_;
}
inline void Reservation::set_delete_time(::google::protobuf::int32 value) {
  set_has_delete_time();
  delete_time_ = value;
}

// -------------------------------------------------------------------

// ReservationList

// repeated .biotech.osla.Reservation reservation = 1;
inline int ReservationList::reservation_size() const {
  return reservation_.size();
}
inline void ReservationList::clear_reservation() {
  reservation_.Clear();
}
inline const ::biotech::osla::Reservation& ReservationList::reservation(int index) const {
  return reservation_.Get(index);
}
inline ::biotech::osla::Reservation* ReservationList::mutable_reservation(int index) {
  return reservation_.Mutable(index);
}
inline ::biotech::osla::Reservation* ReservationList::add_reservation() {
  return reservation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Reservation >&
ReservationList::reservation() const {
  return reservation_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Reservation >*
ReservationList::mutable_reservation() {
  return &reservation_;
}

// -------------------------------------------------------------------

// User

// required int32 id = 1;
inline bool User::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 User::id() const {
  return id_;
}
inline void User::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 status = 2;
inline bool User::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 User::status() const {
  return status_;
}
inline void User::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required string first_name = 3;
inline bool User::has_first_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_first_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_first_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_first_name() {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    first_name_->clear();
  }
  clear_has_first_name();
}
inline const ::std::string& User::first_name() const {
  return *first_name_;
}
inline void User::set_first_name(const ::std::string& value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void User::set_first_name(const char* value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void User::set_first_name(const char* value, size_t size) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_first_name() {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  return first_name_;
}
inline ::std::string* User::release_first_name() {
  clear_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_name_;
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_first_name(::std::string* first_name) {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    delete first_name_;
  }
  if (first_name) {
    set_has_first_name();
    first_name_ = first_name;
  } else {
    clear_has_first_name();
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string last_name = 4;
inline bool User::has_last_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_last_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_last_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_last_name() {
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    last_name_->clear();
  }
  clear_has_last_name();
}
inline const ::std::string& User::last_name() const {
  return *last_name_;
}
inline void User::set_last_name(const ::std::string& value) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(value);
}
inline void User::set_last_name(const char* value) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(value);
}
inline void User::set_last_name(const char* value, size_t size) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_last_name() {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  return last_name_;
}
inline ::std::string* User::release_last_name() {
  clear_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_name_;
    last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_last_name(::std::string* last_name) {
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    delete last_name_;
  }
  if (last_name) {
    set_has_last_name();
    last_name_ = last_name;
  } else {
    clear_has_last_name();
    last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string phone = 5;
inline bool User::has_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& User::phone() const {
  return *phone_;
}
inline void User::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void User::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void User::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* User::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_serial = 6;
inline bool User::has_card_serial() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void User::set_has_card_serial() {
  _has_bits_[0] |= 0x00000020u;
}
inline void User::clear_has_card_serial() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void User::clear_card_serial() {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    card_serial_->clear();
  }
  clear_has_card_serial();
}
inline const ::std::string& User::card_serial() const {
  return *card_serial_;
}
inline void User::set_card_serial(const ::std::string& value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void User::set_card_serial(const char* value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void User::set_card_serial(const char* value, size_t size) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_card_serial() {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  return card_serial_;
}
inline ::std::string* User::release_card_serial() {
  clear_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_serial_;
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_card_serial(::std::string* card_serial) {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    delete card_serial_;
  }
  if (card_serial) {
    set_has_card_serial();
    card_serial_ = card_serial;
  } else {
    clear_has_card_serial();
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 account_id = 7;
inline bool User::has_account_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void User::set_has_account_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void User::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void User::clear_account_id() {
  account_id_ = 0;
  clear_has_account_id();
}
inline ::google::protobuf::int32 User::account_id() const {
  return account_id_;
}
inline void User::set_account_id(::google::protobuf::int32 value) {
  set_has_account_id();
  account_id_ = value;
}

// required int32 isblack = 8;
inline bool User::has_isblack() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void User::set_has_isblack() {
  _has_bits_[0] |= 0x00000080u;
}
inline void User::clear_has_isblack() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void User::clear_isblack() {
  isblack_ = 0;
  clear_has_isblack();
}
inline ::google::protobuf::int32 User::isblack() const {
  return isblack_;
}
inline void User::set_isblack(::google::protobuf::int32 value) {
  set_has_isblack();
  isblack_ = value;
}

// optional int32 penaltyStopStart = 9;
inline bool User::has_penaltystopstart() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void User::set_has_penaltystopstart() {
  _has_bits_[0] |= 0x00000100u;
}
inline void User::clear_has_penaltystopstart() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void User::clear_penaltystopstart() {
  penaltystopstart_ = 0;
  clear_has_penaltystopstart();
}
inline ::google::protobuf::int32 User::penaltystopstart() const {
  return penaltystopstart_;
}
inline void User::set_penaltystopstart(::google::protobuf::int32 value) {
  set_has_penaltystopstart();
  penaltystopstart_ = value;
}

// optional int32 penaltyStopEnd = 10;
inline bool User::has_penaltystopend() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void User::set_has_penaltystopend() {
  _has_bits_[0] |= 0x00000200u;
}
inline void User::clear_has_penaltystopend() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void User::clear_penaltystopend() {
  penaltystopend_ = 0;
  clear_has_penaltystopend();
}
inline ::google::protobuf::int32 User::penaltystopend() const {
  return penaltystopend_;
}
inline void User::set_penaltystopend(::google::protobuf::int32 value) {
  set_has_penaltystopend();
  penaltystopend_ = value;
}

// -------------------------------------------------------------------

// UserList

// repeated .biotech.osla.User user = 1;
inline int UserList::user_size() const {
  return user_.size();
}
inline void UserList::clear_user() {
  user_.Clear();
}
inline const ::biotech::osla::User& UserList::user(int index) const {
  return user_.Get(index);
}
inline ::biotech::osla::User* UserList::mutable_user(int index) {
  return user_.Mutable(index);
}
inline ::biotech::osla::User* UserList::add_user() {
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::User >&
UserList::user() const {
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::User >*
UserList::mutable_user() {
  return &user_;
}

// -------------------------------------------------------------------

// Account

// required int32 id = 1;
inline bool Account::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Account::id() const {
  return id_;
}
inline void Account::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 status = 2;
inline bool Account::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Account::status() const {
  return status_;
}
inline void Account::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int32 group_id = 3;
inline bool Account::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_group_id() {
  group_id_ = 0;
  clear_has_group_id();
}
inline ::google::protobuf::int32 Account::group_id() const {
  return group_id_;
}
inline void Account::set_group_id(::google::protobuf::int32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required int32 deposit = 4;
inline bool Account::has_deposit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Account::set_has_deposit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Account::clear_has_deposit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Account::clear_deposit() {
  deposit_ = 0;
  clear_has_deposit();
}
inline ::google::protobuf::int32 Account::deposit() const {
  return deposit_;
}
inline void Account::set_deposit(::google::protobuf::int32 value) {
  set_has_deposit();
  deposit_ = value;
}

// required int32 credit = 5;
inline bool Account::has_credit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Account::set_has_credit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Account::clear_has_credit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Account::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline ::google::protobuf::int32 Account::credit() const {
  return credit_;
}
inline void Account::set_credit(::google::protobuf::int32 value) {
  set_has_credit();
  credit_ = value;
}

// required int32 credit_temp = 6;
inline bool Account::has_credit_temp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Account::set_has_credit_temp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Account::clear_has_credit_temp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Account::clear_credit_temp() {
  credit_temp_ = 0;
  clear_has_credit_temp();
}
inline ::google::protobuf::int32 Account::credit_temp() const {
  return credit_temp_;
}
inline void Account::set_credit_temp(::google::protobuf::int32 value) {
  set_has_credit_temp();
  credit_temp_ = value;
}

// required int32 credit_temp_expire_time = 7;
inline bool Account::has_credit_temp_expire_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Account::set_has_credit_temp_expire_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Account::clear_has_credit_temp_expire_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Account::clear_credit_temp_expire_time() {
  credit_temp_expire_time_ = 0;
  clear_has_credit_temp_expire_time();
}
inline ::google::protobuf::int32 Account::credit_temp_expire_time() const {
  return credit_temp_expire_time_;
}
inline void Account::set_credit_temp_expire_time(::google::protobuf::int32 value) {
  set_has_credit_temp_expire_time();
  credit_temp_expire_time_ = value;
}

// -------------------------------------------------------------------

// AccountList

// repeated .biotech.osla.Account accout = 1;
inline int AccountList::accout_size() const {
  return accout_.size();
}
inline void AccountList::clear_accout() {
  accout_.Clear();
}
inline const ::biotech::osla::Account& AccountList::accout(int index) const {
  return accout_.Get(index);
}
inline ::biotech::osla::Account* AccountList::mutable_accout(int index) {
  return accout_.Mutable(index);
}
inline ::biotech::osla::Account* AccountList::add_accout() {
  return accout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Account >&
AccountList::accout() const {
  return accout_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Account >*
AccountList::mutable_accout() {
  return &accout_;
}

// -------------------------------------------------------------------

// UserRight

// required int32 user_id = 1;
inline bool UserRight::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRight::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRight::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRight::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 UserRight::user_id() const {
  return user_id_;
}
inline void UserRight::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 right = 2;
inline bool UserRight::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRight::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRight::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRight::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 UserRight::right() const {
  return right_;
}
inline void UserRight::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required int32 right_temp = 3;
inline bool UserRight::has_right_temp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRight::set_has_right_temp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRight::clear_has_right_temp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRight::clear_right_temp() {
  right_temp_ = 0;
  clear_has_right_temp();
}
inline ::google::protobuf::int32 UserRight::right_temp() const {
  return right_temp_;
}
inline void UserRight::set_right_temp(::google::protobuf::int32 value) {
  set_has_right_temp();
  right_temp_ = value;
}

// -------------------------------------------------------------------

// UserRightList

// repeated .biotech.osla.UserRight user_right = 1;
inline int UserRightList::user_right_size() const {
  return user_right_.size();
}
inline void UserRightList::clear_user_right() {
  user_right_.Clear();
}
inline const ::biotech::osla::UserRight& UserRightList::user_right(int index) const {
  return user_right_.Get(index);
}
inline ::biotech::osla::UserRight* UserRightList::mutable_user_right(int index) {
  return user_right_.Mutable(index);
}
inline ::biotech::osla::UserRight* UserRightList::add_user_right() {
  return user_right_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserRight >&
UserRightList::user_right() const {
  return user_right_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserRight >*
UserRightList::mutable_user_right() {
  return &user_right_;
}

// -------------------------------------------------------------------

// TempCardBinding

// required string card_serial = 1;
inline bool TempCardBinding::has_card_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TempCardBinding::set_has_card_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TempCardBinding::clear_has_card_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TempCardBinding::clear_card_serial() {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    card_serial_->clear();
  }
  clear_has_card_serial();
}
inline const ::std::string& TempCardBinding::card_serial() const {
  return *card_serial_;
}
inline void TempCardBinding::set_card_serial(const ::std::string& value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void TempCardBinding::set_card_serial(const char* value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void TempCardBinding::set_card_serial(const char* value, size_t size) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TempCardBinding::mutable_card_serial() {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  return card_serial_;
}
inline ::std::string* TempCardBinding::release_card_serial() {
  clear_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_serial_;
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TempCardBinding::set_allocated_card_serial(::std::string* card_serial) {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    delete card_serial_;
  }
  if (card_serial) {
    set_has_card_serial();
    card_serial_ = card_serial;
  } else {
    clear_has_card_serial();
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 user_id = 2;
inline bool TempCardBinding::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TempCardBinding::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TempCardBinding::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TempCardBinding::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 TempCardBinding::user_id() const {
  return user_id_;
}
inline void TempCardBinding::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 active_time = 3;
inline bool TempCardBinding::has_active_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TempCardBinding::set_has_active_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TempCardBinding::clear_has_active_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TempCardBinding::clear_active_time() {
  active_time_ = 0;
  clear_has_active_time();
}
inline ::google::protobuf::int32 TempCardBinding::active_time() const {
  return active_time_;
}
inline void TempCardBinding::set_active_time(::google::protobuf::int32 value) {
  set_has_active_time();
  active_time_ = value;
}

// required int32 expire_time = 4;
inline bool TempCardBinding::has_expire_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TempCardBinding::set_has_expire_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TempCardBinding::clear_has_expire_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TempCardBinding::clear_expire_time() {
  expire_time_ = 0;
  clear_has_expire_time();
}
inline ::google::protobuf::int32 TempCardBinding::expire_time() const {
  return expire_time_;
}
inline void TempCardBinding::set_expire_time(::google::protobuf::int32 value) {
  set_has_expire_time();
  expire_time_ = value;
}

// optional int32 id = 5;
inline bool TempCardBinding::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TempCardBinding::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TempCardBinding::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TempCardBinding::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TempCardBinding::id() const {
  return id_;
}
inline void TempCardBinding::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// TempCardBindingList

// repeated .biotech.osla.TempCardBinding temp_card_binding = 1;
inline int TempCardBindingList::temp_card_binding_size() const {
  return temp_card_binding_.size();
}
inline void TempCardBindingList::clear_temp_card_binding() {
  temp_card_binding_.Clear();
}
inline const ::biotech::osla::TempCardBinding& TempCardBindingList::temp_card_binding(int index) const {
  return temp_card_binding_.Get(index);
}
inline ::biotech::osla::TempCardBinding* TempCardBindingList::mutable_temp_card_binding(int index) {
  return temp_card_binding_.Mutable(index);
}
inline ::biotech::osla::TempCardBinding* TempCardBindingList::add_temp_card_binding() {
  return temp_card_binding_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::TempCardBinding >&
TempCardBindingList::temp_card_binding() const {
  return temp_card_binding_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::TempCardBinding >*
TempCardBindingList::mutable_temp_card_binding() {
  return &temp_card_binding_;
}

// -------------------------------------------------------------------

// Booking

// required int32 id = 1;
inline bool Booking::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Booking::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Booking::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Booking::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Booking::id() const {
  return id_;
}
inline void Booking::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 user_id = 2;
inline bool Booking::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Booking::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Booking::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Booking::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 Booking::user_id() const {
  return user_id_;
}
inline void Booking::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 start_time = 3;
inline bool Booking::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Booking::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Booking::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Booking::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline ::google::protobuf::int32 Booking::start_time() const {
  return start_time_;
}
inline void Booking::set_start_time(::google::protobuf::int32 value) {
  set_has_start_time();
  start_time_ = value;
}

// required int32 end_time = 4;
inline bool Booking::has_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Booking::set_has_end_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Booking::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Booking::clear_end_time() {
  end_time_ = 0;
  clear_has_end_time();
}
inline ::google::protobuf::int32 Booking::end_time() const {
  return end_time_;
}
inline void Booking::set_end_time(::google::protobuf::int32 value) {
  set_has_end_time();
  end_time_ = value;
}

// required int32 type = 5;
inline bool Booking::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Booking::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Booking::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Booking::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Booking::type() const {
  return type_;
}
inline void Booking::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 status = 6;
inline bool Booking::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Booking::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Booking::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Booking::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Booking::status() const {
  return status_;
}
inline void Booking::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional bool isTips = 7;
inline bool Booking::has_istips() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Booking::set_has_istips() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Booking::clear_has_istips() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Booking::clear_istips() {
  istips_ = false;
  clear_has_istips();
}
inline bool Booking::istips() const {
  return istips_;
}
inline void Booking::set_istips(bool value) {
  set_has_istips();
  istips_ = value;
}

// optional bool isEnd = 8;
inline bool Booking::has_isend() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Booking::set_has_isend() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Booking::clear_has_isend() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Booking::clear_isend() {
  isend_ = false;
  clear_has_isend();
}
inline bool Booking::isend() const {
  return isend_;
}
inline void Booking::set_isend(bool value) {
  set_has_isend();
  isend_ = value;
}

// -------------------------------------------------------------------

// BookingList

// repeated .biotech.osla.Booking booking = 1;
inline int BookingList::booking_size() const {
  return booking_.size();
}
inline void BookingList::clear_booking() {
  booking_.Clear();
}
inline const ::biotech::osla::Booking& BookingList::booking(int index) const {
  return booking_.Get(index);
}
inline ::biotech::osla::Booking* BookingList::mutable_booking(int index) {
  return booking_.Mutable(index);
}
inline ::biotech::osla::Booking* BookingList::add_booking() {
  return booking_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Booking >&
BookingList::booking() const {
  return booking_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Booking >*
BookingList::mutable_booking() {
  return &booking_;
}

// -------------------------------------------------------------------

// Calendar

// required int32 day = 1;
inline bool Calendar::has_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Calendar::set_has_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Calendar::clear_has_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Calendar::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 Calendar::day() const {
  return day_;
}
inline void Calendar::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
}

// required bool is_holiday = 2;
inline bool Calendar::has_is_holiday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Calendar::set_has_is_holiday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Calendar::clear_has_is_holiday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Calendar::clear_is_holiday() {
  is_holiday_ = false;
  clear_has_is_holiday();
}
inline bool Calendar::is_holiday() const {
  return is_holiday_;
}
inline void Calendar::set_is_holiday(bool value) {
  set_has_is_holiday();
  is_holiday_ = value;
}

// optional int32 id = 3;
inline bool Calendar::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Calendar::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Calendar::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Calendar::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Calendar::id() const {
  return id_;
}
inline void Calendar::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// CalendarList

// repeated .biotech.osla.Calendar calendar = 1;
inline int CalendarList::calendar_size() const {
  return calendar_.size();
}
inline void CalendarList::clear_calendar() {
  calendar_.Clear();
}
inline const ::biotech::osla::Calendar& CalendarList::calendar(int index) const {
  return calendar_.Get(index);
}
inline ::biotech::osla::Calendar* CalendarList::mutable_calendar(int index) {
  return calendar_.Mutable(index);
}
inline ::biotech::osla::Calendar* CalendarList::add_calendar() {
  return calendar_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Calendar >&
CalendarList::calendar() const {
  return calendar_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Calendar >*
CalendarList::mutable_calendar() {
  return &calendar_;
}

// -------------------------------------------------------------------

// GlobalConfig

// required int32 account_deposit_limit = 1;
inline bool GlobalConfig::has_account_deposit_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalConfig::set_has_account_deposit_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalConfig::clear_has_account_deposit_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalConfig::clear_account_deposit_limit() {
  account_deposit_limit_ = 0;
  clear_has_account_deposit_limit();
}
inline ::google::protobuf::int32 GlobalConfig::account_deposit_limit() const {
  return account_deposit_limit_;
}
inline void GlobalConfig::set_account_deposit_limit(::google::protobuf::int32 value) {
  set_has_account_deposit_limit();
  account_deposit_limit_ = value;
}

// optional string ftp_host = 2;
inline bool GlobalConfig::has_ftp_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalConfig::set_has_ftp_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalConfig::clear_has_ftp_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalConfig::clear_ftp_host() {
  if (ftp_host_ != &::google::protobuf::internal::kEmptyString) {
    ftp_host_->clear();
  }
  clear_has_ftp_host();
}
inline const ::std::string& GlobalConfig::ftp_host() const {
  return *ftp_host_;
}
inline void GlobalConfig::set_ftp_host(const ::std::string& value) {
  set_has_ftp_host();
  if (ftp_host_ == &::google::protobuf::internal::kEmptyString) {
    ftp_host_ = new ::std::string;
  }
  ftp_host_->assign(value);
}
inline void GlobalConfig::set_ftp_host(const char* value) {
  set_has_ftp_host();
  if (ftp_host_ == &::google::protobuf::internal::kEmptyString) {
    ftp_host_ = new ::std::string;
  }
  ftp_host_->assign(value);
}
inline void GlobalConfig::set_ftp_host(const char* value, size_t size) {
  set_has_ftp_host();
  if (ftp_host_ == &::google::protobuf::internal::kEmptyString) {
    ftp_host_ = new ::std::string;
  }
  ftp_host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_ftp_host() {
  set_has_ftp_host();
  if (ftp_host_ == &::google::protobuf::internal::kEmptyString) {
    ftp_host_ = new ::std::string;
  }
  return ftp_host_;
}
inline ::std::string* GlobalConfig::release_ftp_host() {
  clear_has_ftp_host();
  if (ftp_host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ftp_host_;
    ftp_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_ftp_host(::std::string* ftp_host) {
  if (ftp_host_ != &::google::protobuf::internal::kEmptyString) {
    delete ftp_host_;
  }
  if (ftp_host) {
    set_has_ftp_host();
    ftp_host_ = ftp_host;
  } else {
    clear_has_ftp_host();
    ftp_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ftp_port = 3;
inline bool GlobalConfig::has_ftp_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlobalConfig::set_has_ftp_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlobalConfig::clear_has_ftp_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlobalConfig::clear_ftp_port() {
  if (ftp_port_ != &::google::protobuf::internal::kEmptyString) {
    ftp_port_->clear();
  }
  clear_has_ftp_port();
}
inline const ::std::string& GlobalConfig::ftp_port() const {
  return *ftp_port_;
}
inline void GlobalConfig::set_ftp_port(const ::std::string& value) {
  set_has_ftp_port();
  if (ftp_port_ == &::google::protobuf::internal::kEmptyString) {
    ftp_port_ = new ::std::string;
  }
  ftp_port_->assign(value);
}
inline void GlobalConfig::set_ftp_port(const char* value) {
  set_has_ftp_port();
  if (ftp_port_ == &::google::protobuf::internal::kEmptyString) {
    ftp_port_ = new ::std::string;
  }
  ftp_port_->assign(value);
}
inline void GlobalConfig::set_ftp_port(const char* value, size_t size) {
  set_has_ftp_port();
  if (ftp_port_ == &::google::protobuf::internal::kEmptyString) {
    ftp_port_ = new ::std::string;
  }
  ftp_port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_ftp_port() {
  set_has_ftp_port();
  if (ftp_port_ == &::google::protobuf::internal::kEmptyString) {
    ftp_port_ = new ::std::string;
  }
  return ftp_port_;
}
inline ::std::string* GlobalConfig::release_ftp_port() {
  clear_has_ftp_port();
  if (ftp_port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ftp_port_;
    ftp_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_ftp_port(::std::string* ftp_port) {
  if (ftp_port_ != &::google::protobuf::internal::kEmptyString) {
    delete ftp_port_;
  }
  if (ftp_port) {
    set_has_ftp_port();
    ftp_port_ = ftp_port;
  } else {
    clear_has_ftp_port();
    ftp_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ftp_user_name = 4;
inline bool GlobalConfig::has_ftp_user_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GlobalConfig::set_has_ftp_user_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GlobalConfig::clear_has_ftp_user_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GlobalConfig::clear_ftp_user_name() {
  if (ftp_user_name_ != &::google::protobuf::internal::kEmptyString) {
    ftp_user_name_->clear();
  }
  clear_has_ftp_user_name();
}
inline const ::std::string& GlobalConfig::ftp_user_name() const {
  return *ftp_user_name_;
}
inline void GlobalConfig::set_ftp_user_name(const ::std::string& value) {
  set_has_ftp_user_name();
  if (ftp_user_name_ == &::google::protobuf::internal::kEmptyString) {
    ftp_user_name_ = new ::std::string;
  }
  ftp_user_name_->assign(value);
}
inline void GlobalConfig::set_ftp_user_name(const char* value) {
  set_has_ftp_user_name();
  if (ftp_user_name_ == &::google::protobuf::internal::kEmptyString) {
    ftp_user_name_ = new ::std::string;
  }
  ftp_user_name_->assign(value);
}
inline void GlobalConfig::set_ftp_user_name(const char* value, size_t size) {
  set_has_ftp_user_name();
  if (ftp_user_name_ == &::google::protobuf::internal::kEmptyString) {
    ftp_user_name_ = new ::std::string;
  }
  ftp_user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_ftp_user_name() {
  set_has_ftp_user_name();
  if (ftp_user_name_ == &::google::protobuf::internal::kEmptyString) {
    ftp_user_name_ = new ::std::string;
  }
  return ftp_user_name_;
}
inline ::std::string* GlobalConfig::release_ftp_user_name() {
  clear_has_ftp_user_name();
  if (ftp_user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ftp_user_name_;
    ftp_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_ftp_user_name(::std::string* ftp_user_name) {
  if (ftp_user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ftp_user_name_;
  }
  if (ftp_user_name) {
    set_has_ftp_user_name();
    ftp_user_name_ = ftp_user_name;
  } else {
    clear_has_ftp_user_name();
    ftp_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ftp_passwd = 5;
inline bool GlobalConfig::has_ftp_passwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GlobalConfig::set_has_ftp_passwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GlobalConfig::clear_has_ftp_passwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GlobalConfig::clear_ftp_passwd() {
  if (ftp_passwd_ != &::google::protobuf::internal::kEmptyString) {
    ftp_passwd_->clear();
  }
  clear_has_ftp_passwd();
}
inline const ::std::string& GlobalConfig::ftp_passwd() const {
  return *ftp_passwd_;
}
inline void GlobalConfig::set_ftp_passwd(const ::std::string& value) {
  set_has_ftp_passwd();
  if (ftp_passwd_ == &::google::protobuf::internal::kEmptyString) {
    ftp_passwd_ = new ::std::string;
  }
  ftp_passwd_->assign(value);
}
inline void GlobalConfig::set_ftp_passwd(const char* value) {
  set_has_ftp_passwd();
  if (ftp_passwd_ == &::google::protobuf::internal::kEmptyString) {
    ftp_passwd_ = new ::std::string;
  }
  ftp_passwd_->assign(value);
}
inline void GlobalConfig::set_ftp_passwd(const char* value, size_t size) {
  set_has_ftp_passwd();
  if (ftp_passwd_ == &::google::protobuf::internal::kEmptyString) {
    ftp_passwd_ = new ::std::string;
  }
  ftp_passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_ftp_passwd() {
  set_has_ftp_passwd();
  if (ftp_passwd_ == &::google::protobuf::internal::kEmptyString) {
    ftp_passwd_ = new ::std::string;
  }
  return ftp_passwd_;
}
inline ::std::string* GlobalConfig::release_ftp_passwd() {
  clear_has_ftp_passwd();
  if (ftp_passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ftp_passwd_;
    ftp_passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_ftp_passwd(::std::string* ftp_passwd) {
  if (ftp_passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete ftp_passwd_;
  }
  if (ftp_passwd) {
    set_has_ftp_passwd();
    ftp_passwd_ = ftp_passwd;
  } else {
    clear_has_ftp_passwd();
    ftp_passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ftp_root_url = 6;
inline bool GlobalConfig::has_ftp_root_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GlobalConfig::set_has_ftp_root_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GlobalConfig::clear_has_ftp_root_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GlobalConfig::clear_ftp_root_url() {
  if (ftp_root_url_ != &::google::protobuf::internal::kEmptyString) {
    ftp_root_url_->clear();
  }
  clear_has_ftp_root_url();
}
inline const ::std::string& GlobalConfig::ftp_root_url() const {
  return *ftp_root_url_;
}
inline void GlobalConfig::set_ftp_root_url(const ::std::string& value) {
  set_has_ftp_root_url();
  if (ftp_root_url_ == &::google::protobuf::internal::kEmptyString) {
    ftp_root_url_ = new ::std::string;
  }
  ftp_root_url_->assign(value);
}
inline void GlobalConfig::set_ftp_root_url(const char* value) {
  set_has_ftp_root_url();
  if (ftp_root_url_ == &::google::protobuf::internal::kEmptyString) {
    ftp_root_url_ = new ::std::string;
  }
  ftp_root_url_->assign(value);
}
inline void GlobalConfig::set_ftp_root_url(const char* value, size_t size) {
  set_has_ftp_root_url();
  if (ftp_root_url_ == &::google::protobuf::internal::kEmptyString) {
    ftp_root_url_ = new ::std::string;
  }
  ftp_root_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_ftp_root_url() {
  set_has_ftp_root_url();
  if (ftp_root_url_ == &::google::protobuf::internal::kEmptyString) {
    ftp_root_url_ = new ::std::string;
  }
  return ftp_root_url_;
}
inline ::std::string* GlobalConfig::release_ftp_root_url() {
  clear_has_ftp_root_url();
  if (ftp_root_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ftp_root_url_;
    ftp_root_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_ftp_root_url(::std::string* ftp_root_url) {
  if (ftp_root_url_ != &::google::protobuf::internal::kEmptyString) {
    delete ftp_root_url_;
  }
  if (ftp_root_url) {
    set_has_ftp_root_url();
    ftp_root_url_ = ftp_root_url;
  } else {
    clear_has_ftp_root_url();
    ftp_root_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ServiceTime = 7;
inline bool GlobalConfig::has_servicetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GlobalConfig::set_has_servicetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GlobalConfig::clear_has_servicetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GlobalConfig::clear_servicetime() {
  servicetime_ = 0;
  clear_has_servicetime();
}
inline ::google::protobuf::int32 GlobalConfig::servicetime() const {
  return servicetime_;
}
inline void GlobalConfig::set_servicetime(::google::protobuf::int32 value) {
  set_has_servicetime();
  servicetime_ = value;
}

// optional int32 CaptureTime = 8;
inline bool GlobalConfig::has_capturetime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GlobalConfig::set_has_capturetime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GlobalConfig::clear_has_capturetime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GlobalConfig::clear_capturetime() {
  capturetime_ = 0;
  clear_has_capturetime();
}
inline ::google::protobuf::int32 GlobalConfig::capturetime() const {
  return capturetime_;
}
inline void GlobalConfig::set_capturetime(::google::protobuf::int32 value) {
  set_has_capturetime();
  capturetime_ = value;
}

// optional string working_time = 9;
inline bool GlobalConfig::has_working_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GlobalConfig::set_has_working_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GlobalConfig::clear_has_working_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GlobalConfig::clear_working_time() {
  if (working_time_ != &::google::protobuf::internal::kEmptyString) {
    working_time_->clear();
  }
  clear_has_working_time();
}
inline const ::std::string& GlobalConfig::working_time() const {
  return *working_time_;
}
inline void GlobalConfig::set_working_time(const ::std::string& value) {
  set_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    working_time_ = new ::std::string;
  }
  working_time_->assign(value);
}
inline void GlobalConfig::set_working_time(const char* value) {
  set_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    working_time_ = new ::std::string;
  }
  working_time_->assign(value);
}
inline void GlobalConfig::set_working_time(const char* value, size_t size) {
  set_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    working_time_ = new ::std::string;
  }
  working_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_working_time() {
  set_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    working_time_ = new ::std::string;
  }
  return working_time_;
}
inline ::std::string* GlobalConfig::release_working_time() {
  clear_has_working_time();
  if (working_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = working_time_;
    working_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_working_time(::std::string* working_time) {
  if (working_time_ != &::google::protobuf::internal::kEmptyString) {
    delete working_time_;
  }
  if (working_time) {
    set_has_working_time();
    working_time_ = working_time;
  } else {
    clear_has_working_time();
    working_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool payment_account_enable = 10;
inline bool GlobalConfig::has_payment_account_enable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GlobalConfig::set_has_payment_account_enable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GlobalConfig::clear_has_payment_account_enable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GlobalConfig::clear_payment_account_enable() {
  payment_account_enable_ = false;
  clear_has_payment_account_enable();
}
inline bool GlobalConfig::payment_account_enable() const {
  return payment_account_enable_;
}
inline void GlobalConfig::set_payment_account_enable(bool value) {
  set_has_payment_account_enable();
  payment_account_enable_ = value;
}

// optional string value1 = 11;
inline bool GlobalConfig::has_value1() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GlobalConfig::set_has_value1() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GlobalConfig::clear_has_value1() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GlobalConfig::clear_value1() {
  if (value1_ != &::google::protobuf::internal::kEmptyString) {
    value1_->clear();
  }
  clear_has_value1();
}
inline const ::std::string& GlobalConfig::value1() const {
  return *value1_;
}
inline void GlobalConfig::set_value1(const ::std::string& value) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(value);
}
inline void GlobalConfig::set_value1(const char* value) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(value);
}
inline void GlobalConfig::set_value1(const char* value, size_t size) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_value1() {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  return value1_;
}
inline ::std::string* GlobalConfig::release_value1() {
  clear_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value1_;
    value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_value1(::std::string* value1) {
  if (value1_ != &::google::protobuf::internal::kEmptyString) {
    delete value1_;
  }
  if (value1) {
    set_has_value1();
    value1_ = value1;
  } else {
    clear_has_value1();
    value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value2 = 12;
inline bool GlobalConfig::has_value2() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GlobalConfig::set_has_value2() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GlobalConfig::clear_has_value2() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GlobalConfig::clear_value2() {
  if (value2_ != &::google::protobuf::internal::kEmptyString) {
    value2_->clear();
  }
  clear_has_value2();
}
inline const ::std::string& GlobalConfig::value2() const {
  return *value2_;
}
inline void GlobalConfig::set_value2(const ::std::string& value) {
  set_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    value2_ = new ::std::string;
  }
  value2_->assign(value);
}
inline void GlobalConfig::set_value2(const char* value) {
  set_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    value2_ = new ::std::string;
  }
  value2_->assign(value);
}
inline void GlobalConfig::set_value2(const char* value, size_t size) {
  set_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    value2_ = new ::std::string;
  }
  value2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_value2() {
  set_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    value2_ = new ::std::string;
  }
  return value2_;
}
inline ::std::string* GlobalConfig::release_value2() {
  clear_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value2_;
    value2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_value2(::std::string* value2) {
  if (value2_ != &::google::protobuf::internal::kEmptyString) {
    delete value2_;
  }
  if (value2) {
    set_has_value2();
    value2_ = value2;
  } else {
    clear_has_value2();
    value2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value3 = 13;
inline bool GlobalConfig::has_value3() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GlobalConfig::set_has_value3() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GlobalConfig::clear_has_value3() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GlobalConfig::clear_value3() {
  if (value3_ != &::google::protobuf::internal::kEmptyString) {
    value3_->clear();
  }
  clear_has_value3();
}
inline const ::std::string& GlobalConfig::value3() const {
  return *value3_;
}
inline void GlobalConfig::set_value3(const ::std::string& value) {
  set_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    value3_ = new ::std::string;
  }
  value3_->assign(value);
}
inline void GlobalConfig::set_value3(const char* value) {
  set_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    value3_ = new ::std::string;
  }
  value3_->assign(value);
}
inline void GlobalConfig::set_value3(const char* value, size_t size) {
  set_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    value3_ = new ::std::string;
  }
  value3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_value3() {
  set_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    value3_ = new ::std::string;
  }
  return value3_;
}
inline ::std::string* GlobalConfig::release_value3() {
  clear_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value3_;
    value3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_value3(::std::string* value3) {
  if (value3_ != &::google::protobuf::internal::kEmptyString) {
    delete value3_;
  }
  if (value3) {
    set_has_value3();
    value3_ = value3;
  } else {
    clear_has_value3();
    value3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value4 = 14;
inline bool GlobalConfig::has_value4() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GlobalConfig::set_has_value4() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GlobalConfig::clear_has_value4() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GlobalConfig::clear_value4() {
  if (value4_ != &::google::protobuf::internal::kEmptyString) {
    value4_->clear();
  }
  clear_has_value4();
}
inline const ::std::string& GlobalConfig::value4() const {
  return *value4_;
}
inline void GlobalConfig::set_value4(const ::std::string& value) {
  set_has_value4();
  if (value4_ == &::google::protobuf::internal::kEmptyString) {
    value4_ = new ::std::string;
  }
  value4_->assign(value);
}
inline void GlobalConfig::set_value4(const char* value) {
  set_has_value4();
  if (value4_ == &::google::protobuf::internal::kEmptyString) {
    value4_ = new ::std::string;
  }
  value4_->assign(value);
}
inline void GlobalConfig::set_value4(const char* value, size_t size) {
  set_has_value4();
  if (value4_ == &::google::protobuf::internal::kEmptyString) {
    value4_ = new ::std::string;
  }
  value4_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_value4() {
  set_has_value4();
  if (value4_ == &::google::protobuf::internal::kEmptyString) {
    value4_ = new ::std::string;
  }
  return value4_;
}
inline ::std::string* GlobalConfig::release_value4() {
  clear_has_value4();
  if (value4_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value4_;
    value4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_value4(::std::string* value4) {
  if (value4_ != &::google::protobuf::internal::kEmptyString) {
    delete value4_;
  }
  if (value4) {
    set_has_value4();
    value4_ = value4;
  } else {
    clear_has_value4();
    value4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value5 = 15;
inline bool GlobalConfig::has_value5() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GlobalConfig::set_has_value5() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GlobalConfig::clear_has_value5() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GlobalConfig::clear_value5() {
  if (value5_ != &::google::protobuf::internal::kEmptyString) {
    value5_->clear();
  }
  clear_has_value5();
}
inline const ::std::string& GlobalConfig::value5() const {
  return *value5_;
}
inline void GlobalConfig::set_value5(const ::std::string& value) {
  set_has_value5();
  if (value5_ == &::google::protobuf::internal::kEmptyString) {
    value5_ = new ::std::string;
  }
  value5_->assign(value);
}
inline void GlobalConfig::set_value5(const char* value) {
  set_has_value5();
  if (value5_ == &::google::protobuf::internal::kEmptyString) {
    value5_ = new ::std::string;
  }
  value5_->assign(value);
}
inline void GlobalConfig::set_value5(const char* value, size_t size) {
  set_has_value5();
  if (value5_ == &::google::protobuf::internal::kEmptyString) {
    value5_ = new ::std::string;
  }
  value5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_value5() {
  set_has_value5();
  if (value5_ == &::google::protobuf::internal::kEmptyString) {
    value5_ = new ::std::string;
  }
  return value5_;
}
inline ::std::string* GlobalConfig::release_value5() {
  clear_has_value5();
  if (value5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value5_;
    value5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_value5(::std::string* value5) {
  if (value5_ != &::google::protobuf::internal::kEmptyString) {
    delete value5_;
  }
  if (value5) {
    set_has_value5();
    value5_ = value5;
  } else {
    clear_has_value5();
    value5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value6 = 16;
inline bool GlobalConfig::has_value6() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GlobalConfig::set_has_value6() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GlobalConfig::clear_has_value6() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GlobalConfig::clear_value6() {
  if (value6_ != &::google::protobuf::internal::kEmptyString) {
    value6_->clear();
  }
  clear_has_value6();
}
inline const ::std::string& GlobalConfig::value6() const {
  return *value6_;
}
inline void GlobalConfig::set_value6(const ::std::string& value) {
  set_has_value6();
  if (value6_ == &::google::protobuf::internal::kEmptyString) {
    value6_ = new ::std::string;
  }
  value6_->assign(value);
}
inline void GlobalConfig::set_value6(const char* value) {
  set_has_value6();
  if (value6_ == &::google::protobuf::internal::kEmptyString) {
    value6_ = new ::std::string;
  }
  value6_->assign(value);
}
inline void GlobalConfig::set_value6(const char* value, size_t size) {
  set_has_value6();
  if (value6_ == &::google::protobuf::internal::kEmptyString) {
    value6_ = new ::std::string;
  }
  value6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalConfig::mutable_value6() {
  set_has_value6();
  if (value6_ == &::google::protobuf::internal::kEmptyString) {
    value6_ = new ::std::string;
  }
  return value6_;
}
inline ::std::string* GlobalConfig::release_value6() {
  clear_has_value6();
  if (value6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value6_;
    value6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalConfig::set_allocated_value6(::std::string* value6) {
  if (value6_ != &::google::protobuf::internal::kEmptyString) {
    delete value6_;
  }
  if (value6) {
    set_has_value6();
    value6_ = value6;
  } else {
    clear_has_value6();
    value6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Session

// required int64 id = 1;
inline bool Session::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Session::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Session::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Session::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 Session::id() const {
  return id_;
}
inline void Session::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required int32 start_time = 2;
inline bool Session::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Session::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Session::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Session::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline ::google::protobuf::int32 Session::start_time() const {
  return start_time_;
}
inline void Session::set_start_time(::google::protobuf::int32 value) {
  set_has_start_time();
  start_time_ = value;
}

// required int32 end_time = 3;
inline bool Session::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Session::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Session::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Session::clear_end_time() {
  end_time_ = 0;
  clear_has_end_time();
}
inline ::google::protobuf::int32 Session::end_time() const {
  return end_time_;
}
inline void Session::set_end_time(::google::protobuf::int32 value) {
  set_has_end_time();
  end_time_ = value;
}

// required int32 type = 4;
inline bool Session::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Session::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Session::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Session::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Session::type() const {
  return type_;
}
inline void Session::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 user_id = 5;
inline bool Session::has_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Session::set_has_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Session::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Session::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 Session::user_id() const {
  return user_id_;
}
inline void Session::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required string card_serial = 6;
inline bool Session::has_card_serial() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Session::set_has_card_serial() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Session::clear_has_card_serial() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Session::clear_card_serial() {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    card_serial_->clear();
  }
  clear_has_card_serial();
}
inline const ::std::string& Session::card_serial() const {
  return *card_serial_;
}
inline void Session::set_card_serial(const ::std::string& value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void Session::set_card_serial(const char* value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void Session::set_card_serial(const char* value, size_t size) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Session::mutable_card_serial() {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  return card_serial_;
}
inline ::std::string* Session::release_card_serial() {
  clear_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_serial_;
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Session::set_allocated_card_serial(::std::string* card_serial) {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    delete card_serial_;
  }
  if (card_serial) {
    set_has_card_serial();
    card_serial_ = card_serial;
  } else {
    clear_has_card_serial();
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 user_right = 7;
inline bool Session::has_user_right() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Session::set_has_user_right() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Session::clear_has_user_right() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Session::clear_user_right() {
  user_right_ = 0;
  clear_has_user_right();
}
inline ::google::protobuf::int32 Session::user_right() const {
  return user_right_;
}
inline void Session::set_user_right(::google::protobuf::int32 value) {
  set_has_user_right();
  user_right_ = value;
}

// required int32 account_id = 8;
inline bool Session::has_account_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Session::set_has_account_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Session::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Session::clear_account_id() {
  account_id_ = 0;
  clear_has_account_id();
}
inline ::google::protobuf::int32 Session::account_id() const {
  return account_id_;
}
inline void Session::set_account_id(::google::protobuf::int32 value) {
  set_has_account_id();
  account_id_ = value;
}

// required int32 group_id = 9;
inline bool Session::has_group_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Session::set_has_group_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Session::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Session::clear_group_id() {
  group_id_ = 0;
  clear_has_group_id();
}
inline ::google::protobuf::int32 Session::group_id() const {
  return group_id_;
}
inline void Session::set_group_id(::google::protobuf::int32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional int32 booking_id = 10;
inline bool Session::has_booking_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Session::set_has_booking_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Session::clear_has_booking_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Session::clear_booking_id() {
  booking_id_ = 0;
  clear_has_booking_id();
}
inline ::google::protobuf::int32 Session::booking_id() const {
  return booking_id_;
}
inline void Session::set_booking_id(::google::protobuf::int32 value) {
  set_has_booking_id();
  booking_id_ = value;
}

// required bool penalty_flag = 11;
inline bool Session::has_penalty_flag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Session::set_has_penalty_flag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Session::clear_has_penalty_flag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Session::clear_penalty_flag() {
  penalty_flag_ = false;
  clear_has_penalty_flag();
}
inline bool Session::penalty_flag() const {
  return penalty_flag_;
}
inline void Session::set_penalty_flag(bool value) {
  set_has_penalty_flag();
  penalty_flag_ = value;
}

// required int32 instrument_id = 12;
inline bool Session::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Session::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Session::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Session::clear_instrument_id() {
  instrument_id_ = 0;
  clear_has_instrument_id();
}
inline ::google::protobuf::int32 Session::instrument_id() const {
  return instrument_id_;
}
inline void Session::set_instrument_id(::google::protobuf::int32 value) {
  set_has_instrument_id();
  instrument_id_ = value;
}

// optional int32 long_time_right = 13;
inline bool Session::has_long_time_right() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Session::set_has_long_time_right() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Session::clear_has_long_time_right() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Session::clear_long_time_right() {
  long_time_right_ = 0;
  clear_has_long_time_right();
}
inline ::google::protobuf::int32 Session::long_time_right() const {
  return long_time_right_;
}
inline void Session::set_long_time_right(::google::protobuf::int32 value) {
  set_has_long_time_right();
  long_time_right_ = value;
}

// -------------------------------------------------------------------

// SessionList

// repeated .biotech.osla.Session session = 1;
inline int SessionList::session_size() const {
  return session_.size();
}
inline void SessionList::clear_session() {
  session_.Clear();
}
inline const ::biotech::osla::Session& SessionList::session(int index) const {
  return session_.Get(index);
}
inline ::biotech::osla::Session* SessionList::mutable_session(int index) {
  return session_.Mutable(index);
}
inline ::biotech::osla::Session* SessionList::add_session() {
  return session_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Session >&
SessionList::session() const {
  return session_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Session >*
SessionList::mutable_session() {
  return &session_;
}

// -------------------------------------------------------------------

// UserInTraining

// required int64 session_id = 1;
inline bool UserInTraining::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInTraining::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInTraining::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInTraining::clear_session_id() {
  session_id_ = GOOGLE_LONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::int64 UserInTraining::session_id() const {
  return session_id_;
}
inline void UserInTraining::set_session_id(::google::protobuf::int64 value) {
  set_has_session_id();
  session_id_ = value;
}

// required string card_serial = 2;
inline bool UserInTraining::has_card_serial() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInTraining::set_has_card_serial() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInTraining::clear_has_card_serial() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInTraining::clear_card_serial() {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    card_serial_->clear();
  }
  clear_has_card_serial();
}
inline const ::std::string& UserInTraining::card_serial() const {
  return *card_serial_;
}
inline void UserInTraining::set_card_serial(const ::std::string& value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void UserInTraining::set_card_serial(const char* value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void UserInTraining::set_card_serial(const char* value, size_t size) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInTraining::mutable_card_serial() {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  return card_serial_;
}
inline ::std::string* UserInTraining::release_card_serial() {
  clear_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_serial_;
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInTraining::set_allocated_card_serial(::std::string* card_serial) {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    delete card_serial_;
  }
  if (card_serial) {
    set_has_card_serial();
    card_serial_ = card_serial;
  } else {
    clear_has_card_serial();
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 user_id = 3;
inline bool UserInTraining::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInTraining::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInTraining::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInTraining::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 UserInTraining::user_id() const {
  return user_id_;
}
inline void UserInTraining::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 check_in_time = 4;
inline bool UserInTraining::has_check_in_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInTraining::set_has_check_in_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInTraining::clear_has_check_in_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInTraining::clear_check_in_time() {
  check_in_time_ = 0;
  clear_has_check_in_time();
}
inline ::google::protobuf::int32 UserInTraining::check_in_time() const {
  return check_in_time_;
}
inline void UserInTraining::set_check_in_time(::google::protobuf::int32 value) {
  set_has_check_in_time();
  check_in_time_ = value;
}

// optional int32 rowid = 5;
inline bool UserInTraining::has_rowid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInTraining::set_has_rowid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInTraining::clear_has_rowid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInTraining::clear_rowid() {
  rowid_ = 0;
  clear_has_rowid();
}
inline ::google::protobuf::int32 UserInTraining::rowid() const {
  return rowid_;
}
inline void UserInTraining::set_rowid(::google::protobuf::int32 value) {
  set_has_rowid();
  rowid_ = value;
}

// -------------------------------------------------------------------

// UserInTrainingList

// repeated .biotech.osla.UserInTraining user_in_training = 1;
inline int UserInTrainingList::user_in_training_size() const {
  return user_in_training_.size();
}
inline void UserInTrainingList::clear_user_in_training() {
  user_in_training_.Clear();
}
inline const ::biotech::osla::UserInTraining& UserInTrainingList::user_in_training(int index) const {
  return user_in_training_.Get(index);
}
inline ::biotech::osla::UserInTraining* UserInTrainingList::mutable_user_in_training(int index) {
  return user_in_training_.Mutable(index);
}
inline ::biotech::osla::UserInTraining* UserInTrainingList::add_user_in_training() {
  return user_in_training_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserInTraining >&
UserInTrainingList::user_in_training() const {
  return user_in_training_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserInTraining >*
UserInTrainingList::mutable_user_in_training() {
  return &user_in_training_;
}

// -------------------------------------------------------------------

// UserEvent

// required int64 id = 1;
inline bool UserEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserEvent::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 UserEvent::id() const {
  return id_;
}
inline void UserEvent::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required int32 user_id = 2;
inline bool UserEvent::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserEvent::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserEvent::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserEvent::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 UserEvent::user_id() const {
  return user_id_;
}
inline void UserEvent::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional int32 group_id = 3;
inline bool UserEvent::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserEvent::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserEvent::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserEvent::clear_group_id() {
  group_id_ = 0;
  clear_has_group_id();
}
inline ::google::protobuf::int32 UserEvent::group_id() const {
  return group_id_;
}
inline void UserEvent::set_group_id(::google::protobuf::int32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required string card_serial = 4;
inline bool UserEvent::has_card_serial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserEvent::set_has_card_serial() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserEvent::clear_has_card_serial() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserEvent::clear_card_serial() {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    card_serial_->clear();
  }
  clear_has_card_serial();
}
inline const ::std::string& UserEvent::card_serial() const {
  return *card_serial_;
}
inline void UserEvent::set_card_serial(const ::std::string& value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void UserEvent::set_card_serial(const char* value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void UserEvent::set_card_serial(const char* value, size_t size) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserEvent::mutable_card_serial() {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  return card_serial_;
}
inline ::std::string* UserEvent::release_card_serial() {
  clear_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_serial_;
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserEvent::set_allocated_card_serial(::std::string* card_serial) {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    delete card_serial_;
  }
  if (card_serial) {
    set_has_card_serial();
    card_serial_ = card_serial;
  } else {
    clear_has_card_serial();
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 card_type = 5;
inline bool UserEvent::has_card_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserEvent::set_has_card_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserEvent::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserEvent::clear_card_type() {
  card_type_ = 0;
  clear_has_card_type();
}
inline ::google::protobuf::int32 UserEvent::card_type() const {
  return card_type_;
}
inline void UserEvent::set_card_type(::google::protobuf::int32 value) {
  set_has_card_type();
  card_type_ = value;
}

// required int32 action_type = 6;
inline bool UserEvent::has_action_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserEvent::set_has_action_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserEvent::clear_has_action_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserEvent::clear_action_type() {
  action_type_ = 0;
  clear_has_action_type();
}
inline ::google::protobuf::int32 UserEvent::action_type() const {
  return action_type_;
}
inline void UserEvent::set_action_type(::google::protobuf::int32 value) {
  set_has_action_type();
  action_type_ = value;
}

// required int32 action_result = 7;
inline bool UserEvent::has_action_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserEvent::set_has_action_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserEvent::clear_has_action_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserEvent::clear_action_result() {
  action_result_ = 0;
  clear_has_action_result();
}
inline ::google::protobuf::int32 UserEvent::action_result() const {
  return action_result_;
}
inline void UserEvent::set_action_result(::google::protobuf::int32 value) {
  set_has_action_result();
  action_result_ = value;
}

// required int32 create_time = 8;
inline bool UserEvent::has_create_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserEvent::set_has_create_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserEvent::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserEvent::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 UserEvent::create_time() const {
  return create_time_;
}
inline void UserEvent::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
}

// required int32 instrument_id = 9;
inline bool UserEvent::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserEvent::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserEvent::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserEvent::clear_instrument_id() {
  instrument_id_ = 0;
  clear_has_instrument_id();
}
inline ::google::protobuf::int32 UserEvent::instrument_id() const {
  return instrument_id_;
}
inline void UserEvent::set_instrument_id(::google::protobuf::int32 value) {
  set_has_instrument_id();
  instrument_id_ = value;
}

// -------------------------------------------------------------------

// UserEventList

// repeated .biotech.osla.UserEvent user_event = 1;
inline int UserEventList::user_event_size() const {
  return user_event_.size();
}
inline void UserEventList::clear_user_event() {
  user_event_.Clear();
}
inline const ::biotech::osla::UserEvent& UserEventList::user_event(int index) const {
  return user_event_.Get(index);
}
inline ::biotech::osla::UserEvent* UserEventList::mutable_user_event(int index) {
  return user_event_.Mutable(index);
}
inline ::biotech::osla::UserEvent* UserEventList::add_user_event() {
  return user_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserEvent >&
UserEventList::user_event() const {
  return user_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::UserEvent >*
UserEventList::mutable_user_event() {
  return &user_event_;
}

// -------------------------------------------------------------------

// SystemEvent

// required int64 id = 1;
inline bool SystemEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemEvent::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 SystemEvent::id() const {
  return id_;
}
inline void SystemEvent::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required int32 event_type = 2;
inline bool SystemEvent::has_event_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemEvent::set_has_event_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemEvent::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemEvent::clear_event_type() {
  event_type_ = 0;
  clear_has_event_type();
}
inline ::google::protobuf::int32 SystemEvent::event_type() const {
  return event_type_;
}
inline void SystemEvent::set_event_type(::google::protobuf::int32 value) {
  set_has_event_type();
  event_type_ = value;
}

// optional int64 event_content = 3;
inline bool SystemEvent::has_event_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemEvent::set_has_event_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemEvent::clear_has_event_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemEvent::clear_event_content() {
  event_content_ = GOOGLE_LONGLONG(0);
  clear_has_event_content();
}
inline ::google::protobuf::int64 SystemEvent::event_content() const {
  return event_content_;
}
inline void SystemEvent::set_event_content(::google::protobuf::int64 value) {
  set_has_event_content();
  event_content_ = value;
}

// required int32 create_time = 4;
inline bool SystemEvent::has_create_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemEvent::set_has_create_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemEvent::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemEvent::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 SystemEvent::create_time() const {
  return create_time_;
}
inline void SystemEvent::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
}

// required int32 instrument_id = 5;
inline bool SystemEvent::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SystemEvent::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SystemEvent::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SystemEvent::clear_instrument_id() {
  instrument_id_ = 0;
  clear_has_instrument_id();
}
inline ::google::protobuf::int32 SystemEvent::instrument_id() const {
  return instrument_id_;
}
inline void SystemEvent::set_instrument_id(::google::protobuf::int32 value) {
  set_has_instrument_id();
  instrument_id_ = value;
}

// -------------------------------------------------------------------

// SystemEventList

// repeated .biotech.osla.SystemEvent system_event = 1;
inline int SystemEventList::system_event_size() const {
  return system_event_.size();
}
inline void SystemEventList::clear_system_event() {
  system_event_.Clear();
}
inline const ::biotech::osla::SystemEvent& SystemEventList::system_event(int index) const {
  return system_event_.Get(index);
}
inline ::biotech::osla::SystemEvent* SystemEventList::mutable_system_event(int index) {
  return system_event_.Mutable(index);
}
inline ::biotech::osla::SystemEvent* SystemEventList::add_system_event() {
  return system_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::SystemEvent >&
SystemEventList::system_event() const {
  return system_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::SystemEvent >*
SystemEventList::mutable_system_event() {
  return &system_event_;
}

// -------------------------------------------------------------------

// FtpFileUpload

// required string path = 1;
inline bool FtpFileUpload::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FtpFileUpload::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FtpFileUpload::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FtpFileUpload::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FtpFileUpload::path() const {
  return *path_;
}
inline void FtpFileUpload::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FtpFileUpload::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FtpFileUpload::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FtpFileUpload::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FtpFileUpload::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FtpFileUpload::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string file_name = 2;
inline bool FtpFileUpload::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FtpFileUpload::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FtpFileUpload::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FtpFileUpload::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& FtpFileUpload::file_name() const {
  return *file_name_;
}
inline void FtpFileUpload::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void FtpFileUpload::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void FtpFileUpload::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FtpFileUpload::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* FtpFileUpload::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FtpFileUpload::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .biotech.osla.FTP_FILE_UPLOAD_STATUS status = 3;
inline bool FtpFileUpload::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FtpFileUpload::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FtpFileUpload::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FtpFileUpload::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::biotech::osla::FTP_FILE_UPLOAD_STATUS FtpFileUpload::status() const {
  return static_cast< ::biotech::osla::FTP_FILE_UPLOAD_STATUS >(status_);
}
inline void FtpFileUpload::set_status(::biotech::osla::FTP_FILE_UPLOAD_STATUS value) {
  assert(::biotech::osla::FTP_FILE_UPLOAD_STATUS_IsValid(value));
  set_has_status();
  status_ = value;
}

// required int32 consume_time = 4;
inline bool FtpFileUpload::has_consume_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FtpFileUpload::set_has_consume_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FtpFileUpload::clear_has_consume_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FtpFileUpload::clear_consume_time() {
  consume_time_ = 0;
  clear_has_consume_time();
}
inline ::google::protobuf::int32 FtpFileUpload::consume_time() const {
  return consume_time_;
}
inline void FtpFileUpload::set_consume_time(::google::protobuf::int32 value) {
  set_has_consume_time();
  consume_time_ = value;
}

// required int64 file_size = 5;
inline bool FtpFileUpload::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FtpFileUpload::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FtpFileUpload::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FtpFileUpload::clear_file_size() {
  file_size_ = GOOGLE_LONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::int64 FtpFileUpload::file_size() const {
  return file_size_;
}
inline void FtpFileUpload::set_file_size(::google::protobuf::int64 value) {
  set_has_file_size();
  file_size_ = value;
}

// required string create_time = 6;
inline bool FtpFileUpload::has_create_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FtpFileUpload::set_has_create_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FtpFileUpload::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FtpFileUpload::clear_create_time() {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    create_time_->clear();
  }
  clear_has_create_time();
}
inline const ::std::string& FtpFileUpload::create_time() const {
  return *create_time_;
}
inline void FtpFileUpload::set_create_time(const ::std::string& value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void FtpFileUpload::set_create_time(const char* value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void FtpFileUpload::set_create_time(const char* value, size_t size) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FtpFileUpload::mutable_create_time() {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  return create_time_;
}
inline ::std::string* FtpFileUpload::release_create_time() {
  clear_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_;
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FtpFileUpload::set_allocated_create_time(::std::string* create_time) {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_;
  }
  if (create_time) {
    set_has_create_time();
    create_time_ = create_time;
  } else {
    clear_has_create_time();
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 percentage = 7;
inline bool FtpFileUpload::has_percentage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FtpFileUpload::set_has_percentage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FtpFileUpload::clear_has_percentage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FtpFileUpload::clear_percentage() {
  percentage_ = 0;
  clear_has_percentage();
}
inline ::google::protobuf::int32 FtpFileUpload::percentage() const {
  return percentage_;
}
inline void FtpFileUpload::set_percentage(::google::protobuf::int32 value) {
  set_has_percentage();
  percentage_ = value;
}

// optional int32 localid = 8;
inline bool FtpFileUpload::has_localid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FtpFileUpload::set_has_localid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FtpFileUpload::clear_has_localid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FtpFileUpload::clear_localid() {
  localid_ = 0;
  clear_has_localid();
}
inline ::google::protobuf::int32 FtpFileUpload::localid() const {
  return localid_;
}
inline void FtpFileUpload::set_localid(::google::protobuf::int32 value) {
  set_has_localid();
  localid_ = value;
}

// -------------------------------------------------------------------

// FtpEvent

// required int64 id = 1;
inline bool FtpEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FtpEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FtpEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FtpEvent::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 FtpEvent::id() const {
  return id_;
}
inline void FtpEvent::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required int32 user_id = 2;
inline bool FtpEvent::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FtpEvent::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FtpEvent::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FtpEvent::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 FtpEvent::user_id() const {
  return user_id_;
}
inline void FtpEvent::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 instrument_id = 3;
inline bool FtpEvent::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FtpEvent::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FtpEvent::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FtpEvent::clear_instrument_id() {
  instrument_id_ = 0;
  clear_has_instrument_id();
}
inline ::google::protobuf::int32 FtpEvent::instrument_id() const {
  return instrument_id_;
}
inline void FtpEvent::set_instrument_id(::google::protobuf::int32 value) {
  set_has_instrument_id();
  instrument_id_ = value;
}

// required int32 group_id = 4;
inline bool FtpEvent::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FtpEvent::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FtpEvent::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FtpEvent::clear_group_id() {
  group_id_ = 0;
  clear_has_group_id();
}
inline ::google::protobuf::int32 FtpEvent::group_id() const {
  return group_id_;
}
inline void FtpEvent::set_group_id(::google::protobuf::int32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required int32 actived_account = 5;
inline bool FtpEvent::has_actived_account() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FtpEvent::set_has_actived_account() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FtpEvent::clear_has_actived_account() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FtpEvent::clear_actived_account() {
  actived_account_ = 0;
  clear_has_actived_account();
}
inline ::google::protobuf::int32 FtpEvent::actived_account() const {
  return actived_account_;
}
inline void FtpEvent::set_actived_account(::google::protobuf::int32 value) {
  set_has_actived_account();
  actived_account_ = value;
}

// repeated .biotech.osla.FtpFileUpload file = 6;
inline int FtpEvent::file_size() const {
  return file_.size();
}
inline void FtpEvent::clear_file() {
  file_.Clear();
}
inline const ::biotech::osla::FtpFileUpload& FtpEvent::file(int index) const {
  return file_.Get(index);
}
inline ::biotech::osla::FtpFileUpload* FtpEvent::mutable_file(int index) {
  return file_.Mutable(index);
}
inline ::biotech::osla::FtpFileUpload* FtpEvent::add_file() {
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpFileUpload >&
FtpEvent::file() const {
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpFileUpload >*
FtpEvent::mutable_file() {
  return &file_;
}

// optional int32 localId = 7;
inline bool FtpEvent::has_localid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FtpEvent::set_has_localid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FtpEvent::clear_has_localid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FtpEvent::clear_localid() {
  localid_ = 0;
  clear_has_localid();
}
inline ::google::protobuf::int32 FtpEvent::localid() const {
  return localid_;
}
inline void FtpEvent::set_localid(::google::protobuf::int32 value) {
  set_has_localid();
  localid_ = value;
}

// -------------------------------------------------------------------

// FtpEventList

// repeated .biotech.osla.FtpEvent ftp_event = 1;
inline int FtpEventList::ftp_event_size() const {
  return ftp_event_.size();
}
inline void FtpEventList::clear_ftp_event() {
  ftp_event_.Clear();
}
inline const ::biotech::osla::FtpEvent& FtpEventList::ftp_event(int index) const {
  return ftp_event_.Get(index);
}
inline ::biotech::osla::FtpEvent* FtpEventList::mutable_ftp_event(int index) {
  return ftp_event_.Mutable(index);
}
inline ::biotech::osla::FtpEvent* FtpEventList::add_ftp_event() {
  return ftp_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpEvent >&
FtpEventList::ftp_event() const {
  return ftp_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::FtpEvent >*
FtpEventList::mutable_ftp_event() {
  return &ftp_event_;
}

// -------------------------------------------------------------------

// DeviceCaptureEvent

// required int64 id = 1;
inline bool DeviceCaptureEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceCaptureEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceCaptureEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceCaptureEvent::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 DeviceCaptureEvent::id() const {
  return id_;
}
inline void DeviceCaptureEvent::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required int32 instrumentId = 2;
inline bool DeviceCaptureEvent::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceCaptureEvent::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceCaptureEvent::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceCaptureEvent::clear_instrumentid() {
  instrumentid_ = 0;
  clear_has_instrumentid();
}
inline ::google::protobuf::int32 DeviceCaptureEvent::instrumentid() const {
  return instrumentid_;
}
inline void DeviceCaptureEvent::set_instrumentid(::google::protobuf::int32 value) {
  set_has_instrumentid();
  instrumentid_ = value;
}

// required string deviceName = 3;
inline bool DeviceCaptureEvent::has_devicename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceCaptureEvent::set_has_devicename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceCaptureEvent::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceCaptureEvent::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& DeviceCaptureEvent::devicename() const {
  return *devicename_;
}
inline void DeviceCaptureEvent::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void DeviceCaptureEvent::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void DeviceCaptureEvent::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceCaptureEvent::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* DeviceCaptureEvent::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceCaptureEvent::set_allocated_devicename(::std::string* devicename) {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    delete devicename_;
  }
  if (devicename) {
    set_has_devicename();
    devicename_ = devicename;
  } else {
    clear_has_devicename();
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string deviceValue = 4;
inline bool DeviceCaptureEvent::has_devicevalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceCaptureEvent::set_has_devicevalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceCaptureEvent::clear_has_devicevalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceCaptureEvent::clear_devicevalue() {
  if (devicevalue_ != &::google::protobuf::internal::kEmptyString) {
    devicevalue_->clear();
  }
  clear_has_devicevalue();
}
inline const ::std::string& DeviceCaptureEvent::devicevalue() const {
  return *devicevalue_;
}
inline void DeviceCaptureEvent::set_devicevalue(const ::std::string& value) {
  set_has_devicevalue();
  if (devicevalue_ == &::google::protobuf::internal::kEmptyString) {
    devicevalue_ = new ::std::string;
  }
  devicevalue_->assign(value);
}
inline void DeviceCaptureEvent::set_devicevalue(const char* value) {
  set_has_devicevalue();
  if (devicevalue_ == &::google::protobuf::internal::kEmptyString) {
    devicevalue_ = new ::std::string;
  }
  devicevalue_->assign(value);
}
inline void DeviceCaptureEvent::set_devicevalue(const char* value, size_t size) {
  set_has_devicevalue();
  if (devicevalue_ == &::google::protobuf::internal::kEmptyString) {
    devicevalue_ = new ::std::string;
  }
  devicevalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceCaptureEvent::mutable_devicevalue() {
  set_has_devicevalue();
  if (devicevalue_ == &::google::protobuf::internal::kEmptyString) {
    devicevalue_ = new ::std::string;
  }
  return devicevalue_;
}
inline ::std::string* DeviceCaptureEvent::release_devicevalue() {
  clear_has_devicevalue();
  if (devicevalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicevalue_;
    devicevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceCaptureEvent::set_allocated_devicevalue(::std::string* devicevalue) {
  if (devicevalue_ != &::google::protobuf::internal::kEmptyString) {
    delete devicevalue_;
  }
  if (devicevalue) {
    set_has_devicevalue();
    devicevalue_ = devicevalue;
  } else {
    clear_has_devicevalue();
    devicevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 captureTime = 5;
inline bool DeviceCaptureEvent::has_capturetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceCaptureEvent::set_has_capturetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceCaptureEvent::clear_has_capturetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceCaptureEvent::clear_capturetime() {
  capturetime_ = 0;
  clear_has_capturetime();
}
inline ::google::protobuf::int32 DeviceCaptureEvent::capturetime() const {
  return capturetime_;
}
inline void DeviceCaptureEvent::set_capturetime(::google::protobuf::int32 value) {
  set_has_capturetime();
  capturetime_ = value;
}

// -------------------------------------------------------------------

// DeviceCaptureEventList

// repeated .biotech.osla.DeviceCaptureEvent device_capture_event = 1;
inline int DeviceCaptureEventList::device_capture_event_size() const {
  return device_capture_event_.size();
}
inline void DeviceCaptureEventList::clear_device_capture_event() {
  device_capture_event_.Clear();
}
inline const ::biotech::osla::DeviceCaptureEvent& DeviceCaptureEventList::device_capture_event(int index) const {
  return device_capture_event_.Get(index);
}
inline ::biotech::osla::DeviceCaptureEvent* DeviceCaptureEventList::mutable_device_capture_event(int index) {
  return device_capture_event_.Mutable(index);
}
inline ::biotech::osla::DeviceCaptureEvent* DeviceCaptureEventList::add_device_capture_event() {
  return device_capture_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::DeviceCaptureEvent >&
DeviceCaptureEventList::device_capture_event() const {
  return device_capture_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::DeviceCaptureEvent >*
DeviceCaptureEventList::mutable_device_capture_event() {
  return &device_capture_event_;
}

// -------------------------------------------------------------------

// SessionOpertaionReq

// required int32 id = 1;
inline bool SessionOpertaionReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionOpertaionReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionOpertaionReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionOpertaionReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SessionOpertaionReq::id() const {
  return id_;
}
inline void SessionOpertaionReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 user_id = 2;
inline bool SessionOpertaionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionOpertaionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionOpertaionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionOpertaionReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 SessionOpertaionReq::user_id() const {
  return user_id_;
}
inline void SessionOpertaionReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required string card_serial = 3;
inline bool SessionOpertaionReq::has_card_serial() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionOpertaionReq::set_has_card_serial() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionOpertaionReq::clear_has_card_serial() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionOpertaionReq::clear_card_serial() {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    card_serial_->clear();
  }
  clear_has_card_serial();
}
inline const ::std::string& SessionOpertaionReq::card_serial() const {
  return *card_serial_;
}
inline void SessionOpertaionReq::set_card_serial(const ::std::string& value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void SessionOpertaionReq::set_card_serial(const char* value) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(value);
}
inline void SessionOpertaionReq::set_card_serial(const char* value, size_t size) {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  card_serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionOpertaionReq::mutable_card_serial() {
  set_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    card_serial_ = new ::std::string;
  }
  return card_serial_;
}
inline ::std::string* SessionOpertaionReq::release_card_serial() {
  clear_has_card_serial();
  if (card_serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_serial_;
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionOpertaionReq::set_allocated_card_serial(::std::string* card_serial) {
  if (card_serial_ != &::google::protobuf::internal::kEmptyString) {
    delete card_serial_;
  }
  if (card_serial) {
    set_has_card_serial();
    card_serial_ = card_serial;
  } else {
    clear_has_card_serial();
    card_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 user_role = 4;
inline bool SessionOpertaionReq::has_user_role() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionOpertaionReq::set_has_user_role() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionOpertaionReq::clear_has_user_role() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionOpertaionReq::clear_user_role() {
  user_role_ = 0;
  clear_has_user_role();
}
inline ::google::protobuf::int32 SessionOpertaionReq::user_role() const {
  return user_role_;
}
inline void SessionOpertaionReq::set_user_role(::google::protobuf::int32 value) {
  set_has_user_role();
  user_role_ = value;
}

// required int32 operation_type = 5;
inline bool SessionOpertaionReq::has_operation_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionOpertaionReq::set_has_operation_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SessionOpertaionReq::clear_has_operation_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SessionOpertaionReq::clear_operation_type() {
  operation_type_ = 0;
  clear_has_operation_type();
}
inline ::google::protobuf::int32 SessionOpertaionReq::operation_type() const {
  return operation_type_;
}
inline void SessionOpertaionReq::set_operation_type(::google::protobuf::int32 value) {
  set_has_operation_type();
  operation_type_ = value;
}

// -------------------------------------------------------------------

// SessionOpertaionRep

// required int32 id = 1;
inline bool SessionOpertaionRep::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionOpertaionRep::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionOpertaionRep::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionOpertaionRep::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SessionOpertaionRep::id() const {
  return id_;
}
inline void SessionOpertaionRep::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 status = 2;
inline bool SessionOpertaionRep::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionOpertaionRep::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionOpertaionRep::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionOpertaionRep::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 SessionOpertaionRep::status() const {
  return status_;
}
inline void SessionOpertaionRep::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int32 BookingId = 3;
inline bool SessionOpertaionRep::has_bookingid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionOpertaionRep::set_has_bookingid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionOpertaionRep::clear_has_bookingid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionOpertaionRep::clear_bookingid() {
  bookingid_ = 0;
  clear_has_bookingid();
}
inline ::google::protobuf::int32 SessionOpertaionRep::bookingid() const {
  return bookingid_;
}
inline void SessionOpertaionRep::set_bookingid(::google::protobuf::int32 value) {
  set_has_bookingid();
  bookingid_ = value;
}

// -------------------------------------------------------------------

// Entrust

// required int32 id = 1;
inline bool Entrust::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entrust::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entrust::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entrust::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Entrust::id() const {
  return id_;
}
inline void Entrust::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 user_id = 2;
inline bool Entrust::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entrust::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entrust::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entrust::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 Entrust::user_id() const {
  return user_id_;
}
inline void Entrust::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required string title = 3;
inline bool Entrust::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entrust::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entrust::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entrust::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Entrust::title() const {
  return *title_;
}
inline void Entrust::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Entrust::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Entrust::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entrust::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Entrust::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Entrust::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 4;
inline bool Entrust::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Entrust::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Entrust::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Entrust::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Entrust::status() const {
  return status_;
}
inline void Entrust::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int32 is_doing = 5;
inline bool Entrust::has_is_doing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Entrust::set_has_is_doing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Entrust::clear_has_is_doing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Entrust::clear_is_doing() {
  is_doing_ = 0;
  clear_has_is_doing();
}
inline ::google::protobuf::int32 Entrust::is_doing() const {
  return is_doing_;
}
inline void Entrust::set_is_doing(::google::protobuf::int32 value) {
  set_has_is_doing();
  is_doing_ = value;
}

// -------------------------------------------------------------------

// EntrustList

// repeated .biotech.osla.Entrust entrust = 1;
inline int EntrustList::entrust_size() const {
  return entrust_.size();
}
inline void EntrustList::clear_entrust() {
  entrust_.Clear();
}
inline const ::biotech::osla::Entrust& EntrustList::entrust(int index) const {
  return entrust_.Get(index);
}
inline ::biotech::osla::Entrust* EntrustList::mutable_entrust(int index) {
  return entrust_.Mutable(index);
}
inline ::biotech::osla::Entrust* EntrustList::add_entrust() {
  return entrust_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::Entrust >&
EntrustList::entrust() const {
  return entrust_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::Entrust >*
EntrustList::mutable_entrust() {
  return &entrust_;
}

// -------------------------------------------------------------------

// EntrustEvent

// required int64 id = 1;
inline bool EntrustEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntrustEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntrustEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntrustEvent::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 EntrustEvent::id() const {
  return id_;
}
inline void EntrustEvent::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required int32 entrust_id = 2;
inline bool EntrustEvent::has_entrust_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntrustEvent::set_has_entrust_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntrustEvent::clear_has_entrust_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntrustEvent::clear_entrust_id() {
  entrust_id_ = 0;
  clear_has_entrust_id();
}
inline ::google::protobuf::int32 EntrustEvent::entrust_id() const {
  return entrust_id_;
}
inline void EntrustEvent::set_entrust_id(::google::protobuf::int32 value) {
  set_has_entrust_id();
  entrust_id_ = value;
}

// required int32 status = 3;
inline bool EntrustEvent::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntrustEvent::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntrustEvent::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntrustEvent::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 EntrustEvent::status() const {
  return status_;
}
inline void EntrustEvent::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 is_doing = 4;
inline bool EntrustEvent::has_is_doing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EntrustEvent::set_has_is_doing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EntrustEvent::clear_has_is_doing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EntrustEvent::clear_is_doing() {
  is_doing_ = 0;
  clear_has_is_doing();
}
inline ::google::protobuf::int32 EntrustEvent::is_doing() const {
  return is_doing_;
}
inline void EntrustEvent::set_is_doing(::google::protobuf::int32 value) {
  set_has_is_doing();
  is_doing_ = value;
}

// required int64 session_id = 5;
inline bool EntrustEvent::has_session_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EntrustEvent::set_has_session_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EntrustEvent::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EntrustEvent::clear_session_id() {
  session_id_ = GOOGLE_LONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::int64 EntrustEvent::session_id() const {
  return session_id_;
}
inline void EntrustEvent::set_session_id(::google::protobuf::int64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .biotech.osla.Session sessionInfo = 6;
inline bool EntrustEvent::has_sessioninfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EntrustEvent::set_has_sessioninfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EntrustEvent::clear_has_sessioninfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EntrustEvent::clear_sessioninfo() {
  if (sessioninfo_ != NULL) sessioninfo_->::biotech::osla::Session::Clear();
  clear_has_sessioninfo();
}
inline const ::biotech::osla::Session& EntrustEvent::sessioninfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sessioninfo_ != NULL ? *sessioninfo_ : *default_instance().sessioninfo_;
#else
  return sessioninfo_ != NULL ? *sessioninfo_ : *default_instance_->sessioninfo_;
#endif
}
inline ::biotech::osla::Session* EntrustEvent::mutable_sessioninfo() {
  set_has_sessioninfo();
  if (sessioninfo_ == NULL) sessioninfo_ = new ::biotech::osla::Session;
  return sessioninfo_;
}
inline ::biotech::osla::Session* EntrustEvent::release_sessioninfo() {
  clear_has_sessioninfo();
  ::biotech::osla::Session* temp = sessioninfo_;
  sessioninfo_ = NULL;
  return temp;
}
inline void EntrustEvent::set_allocated_sessioninfo(::biotech::osla::Session* sessioninfo) {
  delete sessioninfo_;
  sessioninfo_ = sessioninfo;
  if (sessioninfo) {
    set_has_sessioninfo();
  } else {
    clear_has_sessioninfo();
  }
}

// -------------------------------------------------------------------

// EntrustEventList

// repeated .biotech.osla.EntrustEvent entrust_event = 1;
inline int EntrustEventList::entrust_event_size() const {
  return entrust_event_.size();
}
inline void EntrustEventList::clear_entrust_event() {
  entrust_event_.Clear();
}
inline const ::biotech::osla::EntrustEvent& EntrustEventList::entrust_event(int index) const {
  return entrust_event_.Get(index);
}
inline ::biotech::osla::EntrustEvent* EntrustEventList::mutable_entrust_event(int index) {
  return entrust_event_.Mutable(index);
}
inline ::biotech::osla::EntrustEvent* EntrustEventList::add_entrust_event() {
  return entrust_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::biotech::osla::EntrustEvent >&
EntrustEventList::entrust_event() const {
  return entrust_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::biotech::osla::EntrustEvent >*
EntrustEventList::mutable_entrust_event() {
  return &entrust_event_;
}

// -------------------------------------------------------------------

// UpgradeParams

// required bool enable = 1;
inline bool UpgradeParams::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeParams::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeParams::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeParams::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool UpgradeParams::enable() const {
  return enable_;
}
inline void UpgradeParams::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// required bool force_upgrade = 2;
inline bool UpgradeParams::has_force_upgrade() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeParams::set_has_force_upgrade() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeParams::clear_has_force_upgrade() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeParams::clear_force_upgrade() {
  force_upgrade_ = false;
  clear_has_force_upgrade();
}
inline bool UpgradeParams::force_upgrade() const {
  return force_upgrade_;
}
inline void UpgradeParams::set_force_upgrade(bool value) {
  set_has_force_upgrade();
  force_upgrade_ = value;
}

// required string new_ver = 3;
inline bool UpgradeParams::has_new_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeParams::set_has_new_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeParams::clear_has_new_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeParams::clear_new_ver() {
  if (new_ver_ != &::google::protobuf::internal::kEmptyString) {
    new_ver_->clear();
  }
  clear_has_new_ver();
}
inline const ::std::string& UpgradeParams::new_ver() const {
  return *new_ver_;
}
inline void UpgradeParams::set_new_ver(const ::std::string& value) {
  set_has_new_ver();
  if (new_ver_ == &::google::protobuf::internal::kEmptyString) {
    new_ver_ = new ::std::string;
  }
  new_ver_->assign(value);
}
inline void UpgradeParams::set_new_ver(const char* value) {
  set_has_new_ver();
  if (new_ver_ == &::google::protobuf::internal::kEmptyString) {
    new_ver_ = new ::std::string;
  }
  new_ver_->assign(value);
}
inline void UpgradeParams::set_new_ver(const char* value, size_t size) {
  set_has_new_ver();
  if (new_ver_ == &::google::protobuf::internal::kEmptyString) {
    new_ver_ = new ::std::string;
  }
  new_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeParams::mutable_new_ver() {
  set_has_new_ver();
  if (new_ver_ == &::google::protobuf::internal::kEmptyString) {
    new_ver_ = new ::std::string;
  }
  return new_ver_;
}
inline ::std::string* UpgradeParams::release_new_ver() {
  clear_has_new_ver();
  if (new_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_ver_;
    new_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradeParams::set_allocated_new_ver(::std::string* new_ver) {
  if (new_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete new_ver_;
  }
  if (new_ver) {
    set_has_new_ver();
    new_ver_ = new_ver;
  } else {
    clear_has_new_ver();
    new_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string from_ver = 4;
inline bool UpgradeParams::has_from_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeParams::set_has_from_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeParams::clear_has_from_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeParams::clear_from_ver() {
  if (from_ver_ != &::google::protobuf::internal::kEmptyString) {
    from_ver_->clear();
  }
  clear_has_from_ver();
}
inline const ::std::string& UpgradeParams::from_ver() const {
  return *from_ver_;
}
inline void UpgradeParams::set_from_ver(const ::std::string& value) {
  set_has_from_ver();
  if (from_ver_ == &::google::protobuf::internal::kEmptyString) {
    from_ver_ = new ::std::string;
  }
  from_ver_->assign(value);
}
inline void UpgradeParams::set_from_ver(const char* value) {
  set_has_from_ver();
  if (from_ver_ == &::google::protobuf::internal::kEmptyString) {
    from_ver_ = new ::std::string;
  }
  from_ver_->assign(value);
}
inline void UpgradeParams::set_from_ver(const char* value, size_t size) {
  set_has_from_ver();
  if (from_ver_ == &::google::protobuf::internal::kEmptyString) {
    from_ver_ = new ::std::string;
  }
  from_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeParams::mutable_from_ver() {
  set_has_from_ver();
  if (from_ver_ == &::google::protobuf::internal::kEmptyString) {
    from_ver_ = new ::std::string;
  }
  return from_ver_;
}
inline ::std::string* UpgradeParams::release_from_ver() {
  clear_has_from_ver();
  if (from_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_ver_;
    from_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradeParams::set_allocated_from_ver(::std::string* from_ver) {
  if (from_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete from_ver_;
  }
  if (from_ver) {
    set_has_from_ver();
    from_ver_ = from_ver;
  } else {
    clear_has_from_ver();
    from_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 size = 5;
inline bool UpgradeParams::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpgradeParams::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpgradeParams::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpgradeParams::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 UpgradeParams::size() const {
  return size_;
}
inline void UpgradeParams::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// required int32 adler32 = 6;
inline bool UpgradeParams::has_adler32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpgradeParams::set_has_adler32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpgradeParams::clear_has_adler32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpgradeParams::clear_adler32() {
  adler32_ = 0;
  clear_has_adler32();
}
inline ::google::protobuf::int32 UpgradeParams::adler32() const {
  return adler32_;
}
inline void UpgradeParams::set_adler32(::google::protobuf::int32 value) {
  set_has_adler32();
  adler32_ = value;
}

// required string url = 7;
inline bool UpgradeParams::has_url() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpgradeParams::set_has_url() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpgradeParams::clear_has_url() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpgradeParams::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& UpgradeParams::url() const {
  return *url_;
}
inline void UpgradeParams::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void UpgradeParams::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void UpgradeParams::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeParams::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* UpgradeParams::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradeParams::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string reversed1 = 8;
inline bool UpgradeParams::has_reversed1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpgradeParams::set_has_reversed1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpgradeParams::clear_has_reversed1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpgradeParams::clear_reversed1() {
  if (reversed1_ != &::google::protobuf::internal::kEmptyString) {
    reversed1_->clear();
  }
  clear_has_reversed1();
}
inline const ::std::string& UpgradeParams::reversed1() const {
  return *reversed1_;
}
inline void UpgradeParams::set_reversed1(const ::std::string& value) {
  set_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    reversed1_ = new ::std::string;
  }
  reversed1_->assign(value);
}
inline void UpgradeParams::set_reversed1(const char* value) {
  set_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    reversed1_ = new ::std::string;
  }
  reversed1_->assign(value);
}
inline void UpgradeParams::set_reversed1(const char* value, size_t size) {
  set_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    reversed1_ = new ::std::string;
  }
  reversed1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeParams::mutable_reversed1() {
  set_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    reversed1_ = new ::std::string;
  }
  return reversed1_;
}
inline ::std::string* UpgradeParams::release_reversed1() {
  clear_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reversed1_;
    reversed1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradeParams::set_allocated_reversed1(::std::string* reversed1) {
  if (reversed1_ != &::google::protobuf::internal::kEmptyString) {
    delete reversed1_;
  }
  if (reversed1) {
    set_has_reversed1();
    reversed1_ = reversed1;
  } else {
    clear_has_reversed1();
    reversed1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string reversed2 = 9;
inline bool UpgradeParams::has_reversed2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UpgradeParams::set_has_reversed2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UpgradeParams::clear_has_reversed2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UpgradeParams::clear_reversed2() {
  if (reversed2_ != &::google::protobuf::internal::kEmptyString) {
    reversed2_->clear();
  }
  clear_has_reversed2();
}
inline const ::std::string& UpgradeParams::reversed2() const {
  return *reversed2_;
}
inline void UpgradeParams::set_reversed2(const ::std::string& value) {
  set_has_reversed2();
  if (reversed2_ == &::google::protobuf::internal::kEmptyString) {
    reversed2_ = new ::std::string;
  }
  reversed2_->assign(value);
}
inline void UpgradeParams::set_reversed2(const char* value) {
  set_has_reversed2();
  if (reversed2_ == &::google::protobuf::internal::kEmptyString) {
    reversed2_ = new ::std::string;
  }
  reversed2_->assign(value);
}
inline void UpgradeParams::set_reversed2(const char* value, size_t size) {
  set_has_reversed2();
  if (reversed2_ == &::google::protobuf::internal::kEmptyString) {
    reversed2_ = new ::std::string;
  }
  reversed2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeParams::mutable_reversed2() {
  set_has_reversed2();
  if (reversed2_ == &::google::protobuf::internal::kEmptyString) {
    reversed2_ = new ::std::string;
  }
  return reversed2_;
}
inline ::std::string* UpgradeParams::release_reversed2() {
  clear_has_reversed2();
  if (reversed2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reversed2_;
    reversed2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradeParams::set_allocated_reversed2(::std::string* reversed2) {
  if (reversed2_ != &::google::protobuf::internal::kEmptyString) {
    delete reversed2_;
  }
  if (reversed2) {
    set_has_reversed2();
    reversed2_ = reversed2;
  } else {
    clear_has_reversed2();
    reversed2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UpgradePlan

// required int32 type = 1;
inline bool UpgradePlan::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradePlan::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradePlan::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradePlan::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UpgradePlan::type() const {
  return type_;
}
inline void UpgradePlan::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int64 start_date = 2;
inline bool UpgradePlan::has_start_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradePlan::set_has_start_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradePlan::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradePlan::clear_start_date() {
  start_date_ = GOOGLE_LONGLONG(0);
  clear_has_start_date();
}
inline ::google::protobuf::int64 UpgradePlan::start_date() const {
  return start_date_;
}
inline void UpgradePlan::set_start_date(::google::protobuf::int64 value) {
  set_has_start_date();
  start_date_ = value;
}

// required int32 interval = 3;
inline bool UpgradePlan::has_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradePlan::set_has_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradePlan::clear_has_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradePlan::clear_interval() {
  interval_ = 0;
  clear_has_interval();
}
inline ::google::protobuf::int32 UpgradePlan::interval() const {
  return interval_;
}
inline void UpgradePlan::set_interval(::google::protobuf::int32 value) {
  set_has_interval();
  interval_ = value;
}

// optional string reversed1 = 4;
inline bool UpgradePlan::has_reversed1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradePlan::set_has_reversed1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradePlan::clear_has_reversed1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradePlan::clear_reversed1() {
  if (reversed1_ != &::google::protobuf::internal::kEmptyString) {
    reversed1_->clear();
  }
  clear_has_reversed1();
}
inline const ::std::string& UpgradePlan::reversed1() const {
  return *reversed1_;
}
inline void UpgradePlan::set_reversed1(const ::std::string& value) {
  set_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    reversed1_ = new ::std::string;
  }
  reversed1_->assign(value);
}
inline void UpgradePlan::set_reversed1(const char* value) {
  set_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    reversed1_ = new ::std::string;
  }
  reversed1_->assign(value);
}
inline void UpgradePlan::set_reversed1(const char* value, size_t size) {
  set_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    reversed1_ = new ::std::string;
  }
  reversed1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradePlan::mutable_reversed1() {
  set_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    reversed1_ = new ::std::string;
  }
  return reversed1_;
}
inline ::std::string* UpgradePlan::release_reversed1() {
  clear_has_reversed1();
  if (reversed1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reversed1_;
    reversed1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradePlan::set_allocated_reversed1(::std::string* reversed1) {
  if (reversed1_ != &::google::protobuf::internal::kEmptyString) {
    delete reversed1_;
  }
  if (reversed1) {
    set_has_reversed1();
    reversed1_ = reversed1;
  } else {
    clear_has_reversed1();
    reversed1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace osla
}  // namespace biotech

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
